<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>45. Editorial</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>45. Editorial</h1><br/><p></p><p><h2>Solution</h2></p><p></p><p><h3></h3></p><p><h3></h3><h3>Approach 1: Greedy</h3></p><p></p><p><h4>Intuition</h4></p><p><small>Let&#39;s say that we&#39;re at the </small><em><small>i</small></em><em><small>th</small></em><small> jump which has a value of </small><code><small>3</small></code><small>, so we have 3 possible destinations for this jump, and the value of the destinations are </small><code><small>3</small></code><small>, </small><code><small>5</small></code><small>, and </small><code><small>2</small></code><small>. All the indexes covered by these ranges are the </small><strong><small>reachable indexes</small></strong><small> after this jump, as the green cells show in the picture below.</small></p><p></p><p><small>If we move on to the jump </small><code><small>i + 1</small></code><small>, the choices of starting indices for jump </small><code><small>i + 1</small></code><small> is exactly the reachable indexes of the jump </small><code><small>i</small></code><small>.</small></p><p><small>We can go on and draw the starting range of the jump </small><code><small>i + 1</small></code><small> and so on, the starting index of each jump is shown in the following picture. With the increase in the number of jumps, our forward distance is also increasing, the first jump that brings us to the last cell is the jump we should choose. It is a workable method, but what is the time complexity?</small></p><p></p><p><small>Since we are guaranteed to reach the last index, the starting range of each jump is always larger than its previous jump (otherwise, we would be stuck at a jump forever). Given the length of </small><code><small>nums</small></code><small> as </small><code><small>n</small></code><small>, in the worst case, we may have </small><em><small>n</small></em><small> jumps and </small><em><small>O</small></em><small>(</small><em><small>n</small></em><small>2</small><small>)</small><small> total updates, which is shown by the area of the blue part of the figure below. Considering the maximum size of the input array, an approach with </small><em><small>O</small></em><small>(</small><em><small>n</small></em><small>2</small><small>)</small><small> time complexity is likely to end up with Time Limit Exceeded!</small></p><p></p><p><small>Let&#39;s try an advanced approach to reduce the time complexity. Unlike the previous idea, we don&#39;t need to consider all of the updates. Take the first jump at index </small><code><small>0</small></code><small> for example, suppose the starting indexes of jump </small><code><small>0</small></code><small> are in the range </small><code><small>[0, 2]</small></code><small>. When looking for the starting indexes of the next jump, do we still consider the range </small><code><small>[0, 2]</small></code><small>? The answer is NO!</small></p><p><small>We want to reach the ending position by using the least number of jumps possible, so there is no reason in reaching an index using more jumps. Therefore, we shall take a greedy approach that tries to reach each index using the least number of jumps and ignore updates that are destined to end in more jumps.</small></p><p><small>Now back to the example, even if we can move to </small><code><small>[0, 2]</small></code><small> in jump </small><code><small>1</small></code><small>, we would not consider doing so since we already covered that range with jump </small><code><small>0</small></code><small>. So the valid range of reachable indexes for jump </small><code><small>1</small></code><small> is </small><code><small>[3, 4]</small></code><small> instead of </small><code><small>[0, 4]</small></code><small>.</small></p><p></p><p><small>In short, if we can reach an index using </small><code><small>j</small></code><small> jumps, we will never consider reaching it using more than </small><code><small>j</small></code><small> jumps. So the updates marked in red will never be considered, because they represent reaching an index with more jumps.</small></p><p></p><p><small>We need two auxiliary marks to help delimit ranges and to avoid repeated visits to the same range:</small><ul><li><code><small>end</small></code><small> is the </small><strong><small>furthest starting index</small></strong><small> of the current jump.</small></li></ul></p><p><ul><li><code><small>far</small></code><small> is the </small><strong><small>furthest reachable index</small></strong><small> of the current jump.</small></li></ul></p><p></p><p></p><p><small>Once we have finished iterating over the range of the current jump (we reach index </small><code><small>end</small></code><small>), the next step is to continue iterating over the reachable indexes that are </small><strong><small>larger</small></strong><small> than </small><code><small>end</small></code><small>, which is represented by the range </small><code><small>[end + 1, far]</small></code><small>. We skip the overlapped range (marked in red) using the greedy approach mentioned before.</small></p><p></p><p><small>Let&#39;s use the following slides as a detailed example:</small></p><p></p><p></p><p></p><p></p><p></p><p>1 / 11</p><p></p><p></p><p></p><p><small>To summarize: the current jump ends when we reach index </small><code><small>end</small></code><small>. Between the current index and </small><code><small>end</small></code><small>, we find the farthest reachable index </small><code><small>far</small></code><small>. At the end of the current jump, we increment our answer and set </small><code><small>end = far</small></code><small> for the next jump.</small></p><p></p><p><h4>Algorithm</h4><ol><li><small>Initialize </small><code><small>curEnd = 0</small></code><small>, </small><code><small>curFar = 0</small></code><small> and the number of jumps as </small><code><small>answer = 0</small></code><small>.</small></li></ol></p><p><ol><li><small>Interate over </small><code><small>nums</small></code><small>, for each index </small><code><small>i</small></code><small>, the farthest index we can reach from </small><code><small>i</small></code><small> is </small><code><small>i + nums[i]</small></code><small>. We update </small><code><small>curFar = max(curFar, i + nums[i])</small></code><small>.</small></li></ol></p><p><ol><li><small>If </small><code><small>i = curEnd</small></code><small>, it means we have finished the current jump, and should move on to the next jump. Increment </small><code><small>answer</small></code><small>, and set </small><code><small>curEnd = curFar</small></code><small> as the furthest we can reach with the next jump. Repeat from step 2.</small></li></ol></p><p></p><p></p><p><h4>Implementation</h4></p><p></p><p><div class="codebox"><pre>function jump(nums: number[]): number {<br />    // The starting <span style="color:#ff9d00;font-weight:700">range</span> of the first jump <span style="color:#ff9d00;font-weight:700">is</span> [<span style="color:#ff0044;font-weight:400">0</span>, <span style="color:#ff0044;font-weight:400">0</span>]<br />    let answer = <span style="color:#ff0044;font-weight:400">0</span>,<br />        n = nums.length;<br />    let curEnd = <span style="color:#ff0044;font-weight:400">0</span>,<br />        curFar = <span style="color:#ff0044;font-weight:400">0</span>;<br />    <span style="color:#ff9d00;font-weight:700">for</span> (let i = <span style="color:#ff0044;font-weight:400">0</span>; i &lt; n - <span style="color:#ff0044;font-weight:400">1</span>; ++i) {<br />        // Update the farthest reachable index of this jump.<br />        curFar = Math.max(curFar, i + nums[i]);<br />        // If we finish the starting <span style="color:#ff9d00;font-weight:700">range</span> of this jump,<br />        // Move on to the starting <span style="color:#ff9d00;font-weight:700">range</span> of the <span style="color:#ff9d00;font-weight:700">next</span> jump.<br />        <span style="color:#ff9d00;font-weight:700">if</span> (i === curEnd) {<br />            ++answer;<br />            curEnd = curFar;<br />        }<br />    }<br />    <span style="color:#ff9d00;font-weight:700">return</span> answer;<br />}</pre></div></p><p></p><p><h4>Complexity Analysis</h4></p><p><small>Let </small><em><small>n</small></em><small> be the length of the input array </small><code><small>nums</small></code><small>.</small><ul><li><small>Time complexity: </small><em><small>O</small></em><small>(</small><em><small>n</small></em><small>)</small></li></ul></p><p><small>We iterate over </small><code><small>nums</small></code><small> and stop at the second last element. In each step of the iteration, we make some calculations that take constant time. Therefore, the overall time complexity is </small><em><small>O</small></em><small>(</small><em><small>n</small></em><small>)</small><small>.</small></p><p><ul><li><small>Space complexity: </small><em><small>O</small></em><small>(1)</small></li></ul></p><p><small>In the iteration, we only need to update three variables, </small><code><small>curEnd</small></code><small>, </small><code><small>curFar</small></code><small> and </small><code><small>answer</small></code><small>, they only take constant space.</small></p><p></p><p></p></div>
</body>
</html>
