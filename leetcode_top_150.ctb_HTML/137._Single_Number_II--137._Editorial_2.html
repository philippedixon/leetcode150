<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>137. Editorial</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>137. Editorial</h1><br/><p>Single Number II</p><p><a href="https://assets.leetcode.com/users/leetcode/avatar_1568224780.png"><img src="images/2-1.png" alt="images/2-1.png" /></a><a href="https://leetcode.com/u/leetcode/">LeetCode</a></p><p></p><p></p><p></p><p>35502</p><p></p><p>Jun 08, 2023</p><p></p><p></p><p></p><p></p><p></p><p>Editorial</p><p></p><p></p><p></p><p></p><p><h2></h2></p><p><h2></h2><h2>Solution</h2></p><p></p><p><h3></h3></p><p><h3></h3><h3>Overview</h3></p><p><small>We are given an integer array </small><code><small>nums</small></code><small> where</small><ul><li>one integer appears <strong>exactly once</strong> and</li><li>all the other integers appear <strong>exactly three times</strong>.</li></ul></p><p></p><p><small>We are supposed to find the lone integer and return it. For complexity analysis, we will use </small><em><small>N</small></em><small> to denote the length of </small><code><small>nums</small></code><small>.</small></p><p><small>The problem description expects us to come up with an algorithm with linear time complexity and constant space complexity. In other words, the time complexity should be </small><em><small>O</small></em><small>(</small><em><small>N</small></em><small>)</small><small>, and the space complexity should be </small><em><small>O</small></em><small>(1)</small><small>.</small></p><p><small>The very naïve approach is to count the frequency of every integer in </small><code><small>nums</small></code><small>. If the frequency of any integer is 1, we can return it. It will take </small><em><small>O</small></em><small>(</small><em><small>N</small></em><small>2</small><small>)</small><small> time and hence is slow.</small></p><p>Pseudocode</p><p></p><p><code>singleNumber(nums) {</code><code></code></p><p><code>    for num in nums {</code><code></code></p><p><code>        freq = 0</code><code></code></p><p><code>        for x in nums {</code><code></code></p><p><code>            if x == num {</code><code></code></p><p><code>                freq += 1</code><code></code></p><p><code>            }</code><code></code></p><p><code>        }</code><code></code></p><p><code>        if freq == 1 {</code><code></code></p><p><code>            loner = num</code><code></code></p><p><code>            break</code><code></code></p><p><code>        }</code><code></code></p><p><code>    }</code><code></code></p><p><code></code><code></code></p><p><code>    return loner</code><code></code></p><p><code>}</code></p><p></p><p></p><p></p><p><small>The article presents a diverse set of approaches to solving this problem. Approaches from </small><a href="https://leetcode.com/problems/single-number-ii/editorial/?envType=study-plan-v2&envId=top-interview-150#approach-4-bit-manipulation">Approach 4</a><small> onwards satisfy both the time and space complexity requirements asked for in the problem description. Readers can jump to </small><a href="https://leetcode.com/problems/single-number-ii/editorial/?envType=study-plan-v2&envId=top-interview-150#approach-4-bit-manipulation">Approach 4</a><small> directly if they are only interested in the </small><em><small>O</small></em><small>(</small><em><small>N</small></em><small>)</small><small> time and </small><em><small>O</small></em><small>(1)</small><small> space complexity solution.</small></p><p></p><p><h3></h3></p><p><h3></h3><h3>Approach 1: Sorting</h3></p><p></p><p><h4>Intuition</h4></p><p><small>Let </small><code><small>nums</small></code><small> be </small><code><small>[20, .........., 20, 20]</small></code><small>. To conclude </small><code><small>20</small></code><small> is not the loner, if we follow the naïve approach given in the </small><a href="https://leetcode.com/problems/single-number-ii/editorial/?envType=study-plan-v2&envId=top-interview-150#overview">Overview</a><small> section, we have to traverse till the very end of the array.</small></p><p><small>What if all </small><code><small>20</small></code><small>s were clustered together? Then we can compare the first occurrence of </small><code><small>20</small></code><small> with the element present at the next index. If they are the same, we can conclude that </small><code><small>20</small></code><small> is not the loner. We don&#39;t need to traverse till the very end of the array.</small></p><p><small>The integers can be clustered together by </small><a href="https://leetcode.com/explore/learn/card/sorting/">sorting</a><small> the array.</small></p><p><small>After sorting, we can </small><strong><small>check every integer with its next integer</small></strong><small> starting from the zeroth index.</small><ul><li><small>If they are the same, we can conclude that the integer is not the loner. We will jump three indices ahead. This is because we are given that </small><strong><small>if an integer is not the loner, it appears exactly three times</small></strong><small>. So, we can skip the next two indices.</small></li></ul></p><p><ul><li><small>Otherwise, we can conclude that the integer is the loner. We will return it.</small></li></ul></p><p></p><p></p><p><small>Now, the last index doesn&#39;t have any next index. Thus, if till the last index, we don&#39;t find any loner, we can conclude that the last integer is the loner because </small><code><small>nums</small></code><small> has exactly one loner.</small></p><p></p><p><h4>Algorithm</h4><ol><li><small>Sort the array </small><code><small>nums</small></code><small>.</small></li></ol></p><p><ol><li><small>Iterate using the </small><code><small>for</small></code><small> loop from index </small><code><small>0</small></code><small> to index </small><code><small>nums.size() - 2</small></code><small> (both inclusive) with a step size of </small><code><small>3</small></code><small>. All these indices will have a next index.</small></li><li><small>If the integer at the current index is the same as the integer at the next index, then continue to the next iteration. This can be checked by </small><code><small>nums[i] == nums[i + 1]</small></code><small>.</small></li></ol></p><p><ul><li><small>Otherwise, return the integer at the current index.</small></li></ul></p><p></p><p></p><p><ul><li><small>Return the integer at the last index, which is </small><code><small>nums[nums.size() - 1]</small></code><small>.</small></li></ul></p><p></p><p></p><p><h4>Implementation</h4></p><p></p><p><div class="codebox"><pre><span style="color:#ff9d00;font-weight:700">class</span> <span style="color:#333333;font-weight:400">Solution</span>:<br />    <span style="color:#ff9d00;font-weight:700">def</span> <span style="color:#333333;font-weight:400">singleNumber</span>(<span style="color:#333333;font-weight:400">self</span>, nums: List[<span style="color:#ff9d00;font-weight:700">int</span>]) -&gt; <span style="color:#ff9d00;font-weight:700">int</span>:<br /><br />        nums.sort()<br /><br />        <span style="color:#ff9d00;font-weight:700">for</span> i <span style="color:#ff9d00;font-weight:700">in</span> <span style="color:#ff9d00;font-weight:700">range</span>(<span style="color:#ff0044;font-weight:400">0</span>, <span style="color:#ff9d00;font-weight:700">len</span>(nums) - <span style="color:#ff0044;font-weight:400">1</span>, <span style="color:#ff0044;font-weight:400">3</span>):<br />            <span style="color:#ff9d00;font-weight:700">if</span> nums[i] == nums[i + <span style="color:#ff0044;font-weight:400">1</span>]:<br />                <span style="color:#ff9d00;font-weight:700">continue</span><br />            <span style="color:#ff9d00;font-weight:700">else</span>:<br />                <span style="color:#ff9d00;font-weight:700">return</span> nums[i]<br /><br />        <span style="color:#ff9d00;font-weight:700">return</span> nums[<span style="color:#ff9d00;font-weight:700">len</span>(nums) - <span style="color:#ff0044;font-weight:400">1</span>]</pre></div></p><p></p><p><h4>Complexity Analysis</h4></p><p><small>Let </small><em><small>N</small></em><small> be the length of </small><code><small>nums</small></code><ul><li><small>Time complexity: </small><em><small>O</small></em><small>(</small><em><small>N</small></em><small>log</small><em><small>N</small></em><small>)</small></li></ul></p><p><small>Sorting can be optimally done in </small><em><small>O</small></em><small>(</small><em><small>N</small></em><small>log</small><em><small>N</small></em><small>)</small><small> time.</small></p><p><small>After sorting, we are traversing the array once. It may take </small><em><small>O</small></em><small>(</small><em><small>N</small></em><small>)</small><small> time.</small></p><p><small>Thus, the overall time complexity is </small><em><small>O</small></em><small>(</small><em><small>N</small></em><small>+</small><em><small>N</small></em><small>log</small><em><small>N</small></em><small>)</small><small> which is </small><em><small>O</small></em><small>(</small><em><small>N</small></em><small>log</small><em><small>N</small></em><small>)</small><small>.</small></p><p><ul><li><small>Space complexity: </small><em><small>O</small></em><small>(</small><em><small>N</small></em><small>)</small><small>.</small></li></ul></p><p><small>It depends on the sorting algorithm. Depending on the programming language, sorting algorithms may need </small><em><small>O</small></em><small>(</small><em><small>N</small></em><small>)</small><small> or </small><em><small>O</small></em><small>(log</small><em><small>N</small></em><small>)</small><small> space.</small></p><p></p><p></p><p></p><p><h3></h3></p><p><h3></h3><h3>Approach 2: Hash Map</h3></p><p></p><p><h4>Intuition</h4></p><p><small>The naïve approach discussed in the </small><a href="https://leetcode.com/problems/single-number-ii/editorial/?envType=study-plan-v2&envId=top-interview-150#overview">Overview</a><small> was based on counting the frequency of integers. It turns out we can use a </small><strong><small>counter</small></strong><small> to count and store the frequency of integers.</small></p><p><strong><small>Counter</small></strong><small> is a key-value pair where the key is the element and the value is the frequency of the element in a sequence.</small></p><p><small>The following diagram illustrates the counter of an arbitrary array. It is not </small><code><small>nums</small></code><small> because </small><code><small>nums</small></code><small> can have only two frequencies: </small><small>1</small><small> and </small><small>3</small><small>.</small></p><p></p><p></p><p><small>We can build a counter from </small><code><small>nums</small></code><small> and then iterate over it to find the loner.</small></p><p><small>Counter can be built in </small><em><small>O</small></em><small>(</small><em><small>N</small></em><small>)</small><small> time using a hash map. Iterate over the array</small><ul><li>If this is the first occurrence of the integer, then save it in the counter as a key, with value as <small>1</small>.</li><li>Otherwise, increment the value of the key by <small>1</small>.</li></ul></p><p></p><p><small>Then we can iterate over the counter to find the key which has a value of </small><small>1</small><small>.</small></p><p></p><p><h4>Algorithm</h4><ol><li><small>Initialize a key-value pair </small><code><small>freq</small></code><small>. Its key will be the integer and its value will be the frequency of the integer in </small><code><small>nums</small></code><small>.</small></li></ol></p><p><ol><li><small>Iterate over </small><code><small>nums</small></code><small> using the </small><code><small>for</small></code><small> loop.</small></li><li><small>If this is the first occurrence of the integer, then save it in </small><code><small>freq</small></code><small> as the key, with value as </small><small>1</small><small>.</small></li></ol></p><p><ul><li><small>Otherwise, increment the value of the key by </small><small>1</small><small>.</small></li></ul></p><p></p><p></p><p><ul><li><small>Iterate over key-value pairs of </small><code><small>freq</small></code><small> using the </small><code><small>for</small></code><small> loop. If the value is </small><small>1</small><small>, then return the key.</small></li></ul></p><p></p><p></p><p><h4>Implementation</h4></p><p><strong><small>Note :</small></strong><small> Python offers a built-in class </small><code><a href="https://docs.python.org/3/library/collections.html#collections.Counter">Counter</a></code><small> to build a counter.</small></p><p><div class="codebox"><pre><span style="color:#ff9d00;font-weight:700">class</span> <span style="color:#333333;font-weight:400">Solution</span>:<br />    <span style="color:#ff9d00;font-weight:700">def</span> <span style="color:#333333;font-weight:400">singleNumber</span>(<span style="color:#333333;font-weight:400">self</span>, nums: List[<span style="color:#ff9d00;font-weight:700">int</span>]) -&gt; <span style="color:#ff9d00;font-weight:700">int</span>:<br /><br />        freq = {}<br /><br />        <span style="color:#ff9d00;font-weight:700">for</span> num <span style="color:#ff9d00;font-weight:700">in</span> nums:<br />            <span style="color:#ff9d00;font-weight:700">if</span> num <span style="color:#ff9d00;font-weight:700">not</span> <span style="color:#ff9d00;font-weight:700">in</span> freq:<br />                freq[num] = <span style="color:#ff0044;font-weight:400">1</span><br />            <span style="color:#ff9d00;font-weight:700">else</span>:<br />                freq[num] += <span style="color:#ff0044;font-weight:400">1</span><br /><br />        <span style="color:#ff9d00;font-weight:700">for</span> key <span style="color:#ff9d00;font-weight:700">in</span> freq:<br />            <span style="color:#ff9d00;font-weight:700">if</span> freq[key] == <span style="color:#ff0044;font-weight:400">1</span>:<br />                <span style="color:#ff9d00;font-weight:700">return</span> key</pre></div></p><p><h4>Complexity Analysis</h4></p><p><small>Let </small><em><small>N</small></em><small> be the length of </small><code><small>nums</small></code><ul><li><small>Time complexity: </small><em><small>O</small></em><small>(</small><em><small>N</small></em><small>)</small></li></ul></p><p><small>Building counter from </small><code><small>nums</small></code><small> can be done in </small><em><small>O</small></em><small>(</small><em><small>N</small></em><small>)</small><small> time.</small></p><p><small>Iterating over the counter can be done in </small><em><small>O</small></em><small>(</small><em><small>N</small></em><small>)</small><small> time.</small></p><p><small>Thus, overall time complexity is </small><em><small>O</small></em><small>(</small><em><small>N</small></em><small>+</small><em><small>N</small></em><small>)</small><small> which is </small><em><small>O</small></em><small>(</small><em><small>N</small></em><small>)</small><small>.</small></p><p><ul><li><small>Space complexity: </small><em><small>O</small></em><small>(</small><em><small>N</small></em><small>)</small><small>.</small></li></ul></p><p><small>We are using a counter to store the frequency of integers. There will be approximately </small><small>3</small><em><small>N</small></em><small>​</small><small> such integers. So, the space complexity is </small><em><small>O</small></em><small>(</small><small>3</small><em><small>N</small></em><small>​</small><small>)</small><small> which is </small><em><small>O</small></em><small>(</small><em><small>N</small></em><small>)</small><small>.</small></p><p></p><p></p><p></p><p><h3></h3></p><p><h3></h3><h3>Approach 3: Mathematics</h3></p><p></p><p><h4>Intuition</h4></p><p><small>Given an array, its set counterpart </small><code><small>num_set</small></code><small> will have all the integers of the array, but without duplicates.</small></p><p><small>Let there be </small><em><small>k</small></em><small> integers that have three occurrences in the array. These integers can be enumerated as </small><em><small>x</small></em><small>1​</small><small>,</small><em><small>x</small></em><small>2​</small><small>,…,</small><em><small>x</small></em><em><small>k</small></em><small>​</small><small>. Let </small><em><small>y</small></em><small> be the loner.</small></p><p><small>Then, our </small><code><small>nums</small></code><small> will be </small><small>[</small><em><small>x</small></em><small>1​</small><small>,</small><em><small>x</small></em><small>1​</small><small>,</small><em><small>x</small></em><small>1​</small><small>,</small><em><small>x</small></em><small>2​</small><small>,</small><em><small>x</small></em><small>2​</small><small>,</small><em><small>x</small></em><small>2​</small><small>,…,</small><em><small>x</small></em><em><small>k</small></em><small>​</small><small>,</small><em><small>x</small></em><em><small>k</small></em><small>​</small><small>,</small><em><small>x</small></em><em><small>k</small></em><small>​</small><small>,</small><em><small>y</small></em><small>]</small><small>.</small></p><p><small>And our </small><code><small>num_set</small></code><small> will be </small><small>{</small><em><small>x</small></em><small>1​</small><small>,</small><em><small>x</small></em><small>2​</small><small>,…,</small><em><small>x</small></em><em><small>k</small></em><small>​</small><small>,</small><em><small>y</small></em><small>}</small><small>.</small></p><p><small>The sum of the </small><code><small>num_set</small></code><small> will be</small><small></small></p><p><small></small><em><small>S</small></em><em><small>set</small></em><small>​</small><small>=</small><em><small>x</small></em><small>1​</small><small>+</small><em><small>x</small></em><small>2​</small><small>+⋯+</small><em><small>x</small></em><em><small>k</small></em><small>​</small><small>+</small><em><small>y</small></em><small>, or</small><small></small></p><p><small></small><em><small>S</small></em><em><small>set</small></em><small>​</small><small>−</small><em><small>y</small></em><small>=</small><em><small>x</small></em><small>1​</small><small>+</small><em><small>x</small></em><small>2​</small><small>+⋯+</small><em><small>x</small></em><em><small>k</small></em><small>​</small><small>​</small></p><p><small>The sum of </small><code><small>nums</small></code><small> will be</small><small></small></p><p><small></small><em><small>S</small></em><em><small>nums</small></em><small>​</small><small>=3</small><em><small>x</small></em><small>1​</small><small>+3</small><em><small>x</small></em><small>2​</small><small>+⋯+3</small><em><small>x</small></em><em><small>k</small></em><small>​</small><small>+</small><em><small>y</small></em><small></small></p><p><small></small><em><small>S</small></em><em><small>nums</small></em><small>​</small><small>=3(</small><em><small>x</small></em><small>1​</small><small>+</small><em><small>x</small></em><small>2​</small><small>+⋯+</small><em><small>x</small></em><em><small>k</small></em><small>​</small><small>)​+</small><em><small>y</small></em><small></small></p><p><small></small><em><small>S</small></em><em><small>nums</small></em><small>​</small><small>=3(</small><em><small>S</small></em><em><small>set</small></em><small>​</small><small>−</small><em><small>y</small></em><small>)​+</small><em><small>y</small></em><small></small></p><p><small></small><em><small>S</small></em><em><small>nums</small></em><small>​</small><small>=3</small><em><small>S</small></em><em><small>set</small></em><small>​</small><small>−3</small><em><small>y</small></em><small>+</small><em><small>y</small></em><small></small></p><p><small></small><em><small>S</small></em><em><small>nums</small></em><small>​</small><small>=3</small><em><small>S</small></em><em><small>set</small></em><small>​</small><small>−2</small><em><small>y</small></em></p><p><small>Therfore, our loner </small><em><small>y</small></em><small> will be</small><small></small></p><p><small></small><em><small>y</small></em><small>=(</small><small>23</small><em><small>S</small></em><em><small>set</small></em><small>​</small><small>−</small><em><small>S</small></em><em><small>nums</small></em><small>​</small><small>​</small><small>)​</small></p><p><small>And hence we can find the loner!</small></p><p></p><p><h4>Algorithm</h4><ol><li><small>Prepare a set from </small><code><small>nums</small></code><small>. Let&#39;s call it </small><code><small>nums_set</small></code><small>.</small></li></ol></p><p><ol><li><small>Compute the sum of </small><code><small>nums_set</small></code><small>. Let&#39;s call it </small><code><small>s_set</small></code><small>.</small></li></ol></p><p><ol><li><small>Compute sum of </small><code><small>nums</small></code><small>. Let&#39;s call it </small><code><small>s_nums</small></code><small>.</small></li></ol></p><p><ol><li><small>Return </small><code><small>((3 * s_set) - s_nums) / 2</small></code><small>. This is backed by the mathematical proof above.</small></li></ol></p><p></p><p><small>Instead of using multiple variables, users can combine the logic in a few lines of code.</small></p><p></p><p><h4>Implementation</h4></p><p><strong><small>Implementation Note:</small></strong><small> Observe constraints given in the problem description carefully.</small></p><p><small>It is given that the integers are in the range </small><small>[−2</small><small>31</small><small>,2</small><small>31</small><small>−1]</small><small>. So, the sum of integers can be very large. Thus, we need to use </small><code><small>long</small></code><small> to avoid integer overflow.</small></p><p><small>Also, all previous approaches can be used if instead of integer, we have string or any other data type. But this approach can only be used if we have integers since we are using mathematical operations.</small></p><p><div class="codebox"><pre><span style="color:#ff9d00;font-weight:700">class</span> <span style="color:#333333;font-weight:400">Solution</span>:<br />    <span style="color:#ff9d00;font-weight:700">def</span> <span style="color:#333333;font-weight:400">singleNumber</span>(<span style="color:#333333;font-weight:400">self</span>, nums: List[<span style="color:#ff9d00;font-weight:700">int</span>]) -&gt; <span style="color:#ff9d00;font-weight:700">int</span>:<br />        <span style="color:#ff9d00;font-weight:700">return</span> (<span style="color:#ff0044;font-weight:400">3</span> * <span style="color:#ff9d00;font-weight:700">sum</span>(<span style="color:#ff9d00;font-weight:700">set</span>(nums)) - <span style="color:#ff9d00;font-weight:700">sum</span>(nums)) // <span style="color:#ff0044;font-weight:400">2</span></pre></div></p><p><h4>Complexity Analysis</h4></p><p><small>Let </small><em><small>N</small></em><small> be the length of </small><code><small>nums</small></code><ul><li><small>Time complexity: </small><em><small>O</small></em><small>(</small><em><small>N</small></em><small>)</small></li></ul></p><p><small>Building a set from </small><code><small>nums</small></code><small> can be done in </small><em><small>O</small></em><small>(</small><em><small>N</small></em><small>)</small><small> time.</small></p><p><small>Iterating over the set can be done in </small><em><small>O</small></em><small>(</small><em><small>N</small></em><small>)</small><small> time.</small></p><p><small>Thus, overall time complexity is </small><em><small>O</small></em><small>(</small><em><small>N</small></em><small>+</small><em><small>N</small></em><small>)</small><small> which is </small><em><small>O</small></em><small>(</small><em><small>N</small></em><small>)</small><small>.</small></p><p><ul><li><small>Space complexity: </small><em><small>O</small></em><small>(</small><em><small>N</small></em><small>)</small><small>.</small></li></ul></p><p><small>We are using a set to store the integers. There will be approximately </small><small>3</small><em><small>N</small></em><small>​</small><small> such integers. So, the space complexity is </small><em><small>O</small></em><small>(</small><small>3</small><em><small>N</small></em><small>​</small><small>)</small><small> which is </small><em><small>O</small></em><small>(</small><em><small>N</small></em><small>)</small><small>.</small></p><p></p><p></p><p></p><p><h3></h3></p><p><h3></h3><h3>Approach 4: Bit Manipulation</h3></p><p></p><p><h4>Intuition</h4></p><p><small>Bit manipulation is the act of manipulating bits. At the heart of bit manipulation are the bit-wise operators.</small></p><p><strong>For quick review of bit-wise operators, click here</strong><ul><li><strong><small>NOT:</small></strong><small> Bitwise NOT is a unary operator that flips the bits of the integer. If the current bit is </small><small>0</small><small>, it will change it to </small><small>1</small><small> and vice versa. The symbol of the bitwise NOT operator is tilde (</small><code><small>~</small></code><small>).</small></li></ul></p><p><code>N </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">5</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">101</span></code><code> </code><code><span style="color:#2b2b2b;">(in</span></code><code> </code><code><span style="color:#569cd6;">binary</span></code><code><span style="color:#2b2b2b;">)</span></code><code></code></p><p><code></code><code><span style="color:#2b2b2b;">~</span></code><code>N </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#2b2b2b;">~(</span></code><code><span style="color:#b5cea8;">101</span></code><code><span style="color:#2b2b2b;">)</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">010</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">2</span></code><code> </code><code><span style="color:#2b2b2b;">(in</span></code><code> </code><code><span style="color:#569cd6;">decimal</span></code><code><span style="color:#2b2b2b;">)</span></code></p><p></p><p></p><p><ul><li><strong><small>AND:</small></strong><small> If both bits in the compared position of the operand are </small><small>1</small><small>, the bit in the resulting bit pattern is </small><small>1</small><small>, otherwise </small><small>0</small><small>. The symbol of the bitwise AND operator is ampersand (</small><code><small>&amp;</small></code><small>).</small></li></ul></p><p><code>A </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">5</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">101</span></code><code> </code><code><span style="color:#2b2b2b;">(in</span></code><code> </code><code><span style="color:#569cd6;">binary</span></code><code><span style="color:#2b2b2b;">)</span></code><code> </code><code></code></p><p><code>B </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">1</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">001</span></code><code> </code><code><span style="color:#2b2b2b;">(in</span></code><code> </code><code><span style="color:#569cd6;">binary</span></code><code><span style="color:#2b2b2b;">)</span></code><code> </code><code></code></p><p><code>A </code><code><span style="color:#2b2b2b;">&amp;</span></code><code> B </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">101</span></code><code> </code><code><span style="color:#2b2b2b;">&amp;</span></code><code> </code><code><span style="color:#b5cea8;">001</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">001</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">1</span></code><code> </code><code><span style="color:#2b2b2b;">(in</span></code><code> </code><code><span style="color:#569cd6;">decimal</span></code><code><span style="color:#2b2b2b;">)</span></code></p><p></p><p></p><p><ul><li><strong><small>OR:</small></strong><small> If both bits in the compared position of the operand are </small><small>0</small><small>, the bit in the resulting bit pattern is </small><small>0</small><small>, otherwise </small><small>1</small><small>. The symbol of the bitwise OR operator is pipe (</small><code><small>|</small></code><small>).</small></li></ul></p><p><code>A </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">5</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">101</span></code><code> </code><code><span style="color:#2b2b2b;">(in</span></code><code> </code><code><span style="color:#569cd6;">binary</span></code><code><span style="color:#2b2b2b;">)</span></code><code> </code><code></code></p><p><code>B </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">1</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">001</span></code><code> </code><code><span style="color:#2b2b2b;">(in</span></code><code> </code><code><span style="color:#569cd6;">binary</span></code><code><span style="color:#2b2b2b;">)</span></code><code> </code><code></code></p><p><code>A </code><code><span style="color:#2b2b2b;">|</span></code><code> B </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">101</span></code><code> </code><code><span style="color:#2b2b2b;">|</span></code><code> </code><code><span style="color:#b5cea8;">001</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">101</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">5</span></code><code> </code><code><span style="color:#2b2b2b;">(in</span></code><code> </code><code><span style="color:#569cd6;">decimal</span></code><code><span style="color:#2b2b2b;">)</span></code></p><p></p><p></p><p><ul><li><strong><small>XOR:</small></strong><small> In bitwise XOR if both bits are the same, the result will be </small><small>0</small><small>, otherwise </small><small>1</small><small>. The symbol of the bitwise XOR operator is caret (</small><code><small>^</small></code><small>).</small></li></ul></p><p><code>A </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">5</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">101</span></code><code> </code><code><span style="color:#2b2b2b;">(in</span></code><code> </code><code><span style="color:#569cd6;">binary</span></code><code><span style="color:#2b2b2b;">)</span></code><code> </code><code></code></p><p><code>B </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">1</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">001</span></code><code> </code><code><span style="color:#2b2b2b;">(in</span></code><code> </code><code><span style="color:#569cd6;">binary</span></code><code><span style="color:#2b2b2b;">)</span></code><code> </code><code></code></p><p><code>A </code><code><span style="color:#2b2b2b;">^</span></code><code> B </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">101</span></code><code> </code><code><span style="color:#2b2b2b;">^</span></code><code> </code><code><span style="color:#b5cea8;">001</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">100</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">4</span></code><code> </code><code><span style="color:#2b2b2b;">(in</span></code><code> </code><code><span style="color:#569cd6;">decimal</span></code><code><span style="color:#2b2b2b;">)</span></code></p><p></p><p></p><p><ul><li><strong><small>Left Shift:</small></strong><small> Left shift operator is a binary operator which shifts bits to the left by a certain number of positions and appends </small><code><small>0</small></code><small> at the right side. One left shift is equivalent to multiplying the bit pattern with </small><small>2</small><small>. The symbol of the left shift operator is </small><code><small>&lt;&lt;</small></code><small>.</small></li></ul></p><p><code><small>x &lt;&lt; y</small></code><small> means left shift </small><code><small>x</small></code><small> by </small><code><small>y</small></code><small> bits, which is equivalent to multiplying </small><code><small>x</small></code><small> with </small><small>2</small><em><small>y</small></em><small>.</small></p><p><code>A </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">1</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">001</span></code><code> </code><code><span style="color:#2b2b2b;">(in</span></code><code> </code><code><span style="color:#569cd6;">binary</span></code><code><span style="color:#2b2b2b;">)</span></code><code> </code><code></code></p><p><code>A </code><code><span style="color:#2b2b2b;">&lt;&lt;</span></code><code> </code><code><span style="color:#b5cea8;">1</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">001</span></code><code> </code><code><span style="color:#2b2b2b;">&lt;&lt;</span></code><code> </code><code><span style="color:#b5cea8;">1</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">010</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">2</span></code><code> </code><code><span style="color:#2b2b2b;">(in</span></code><code> </code><code><span style="color:#569cd6;">decimal</span></code><code><span style="color:#2b2b2b;">)</span></code><code></code></p><p><code>A </code><code><span style="color:#2b2b2b;">&lt;&lt;</span></code><code> </code><code><span style="color:#b5cea8;">2</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">001</span></code><code> </code><code><span style="color:#2b2b2b;">&lt;&lt;</span></code><code> </code><code><span style="color:#b5cea8;">2</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">100</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">4</span></code><code> </code><code><span style="color:#2b2b2b;">(in</span></code><code> </code><code><span style="color:#569cd6;">decimal</span></code><code><span style="color:#2b2b2b;">)</span></code><code></code></p><p><code></code><code></code></p><p><code>B </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">5</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">00101</span></code><code> </code><code><span style="color:#2b2b2b;">(in</span></code><code> </code><code><span style="color:#569cd6;">binary</span></code><code><span style="color:#2b2b2b;">)</span></code><code></code></p><p><code>B </code><code><span style="color:#2b2b2b;">&lt;&lt;</span></code><code> </code><code><span style="color:#b5cea8;">1</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">00101</span></code><code> </code><code><span style="color:#2b2b2b;">&lt;&lt;</span></code><code> </code><code><span style="color:#b5cea8;">1</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">01010</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">10</span></code><code> </code><code><span style="color:#2b2b2b;">(in</span></code><code> </code><code><span style="color:#569cd6;">decimal</span></code><code><span style="color:#2b2b2b;">)</span></code><code></code></p><p><code>B </code><code><span style="color:#2b2b2b;">&lt;&lt;</span></code><code> </code><code><span style="color:#b5cea8;">2</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">00101</span></code><code> </code><code><span style="color:#2b2b2b;">&lt;&lt;</span></code><code> </code><code><span style="color:#b5cea8;">2</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">10100</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">20</span></code><code> </code><code><span style="color:#2b2b2b;">(in</span></code><code> </code><code><span style="color:#569cd6;">decimal</span></code><code><span style="color:#2b2b2b;">)</span></code></p><p></p><p></p><p><ul><li><strong><small>Right Shift:</small></strong><small> Right shift operator is a binary operator which shifts bits to the right by a certain number of positions and appends </small><code><small>0</small></code><small> at the left side. One right shift is equivalent to dividing the bit pattern with </small><small>2</small><small>. The symbol of the right shift operator is </small><code><small>&gt;&gt;</small></code><small>.</small></li></ul></p><p><code><small>x &gt;&gt; y</small></code><small> means right shift </small><code><small>x</small></code><small> by </small><code><small>y</small></code><small> bits, which is equivalent to dividing </small><code><small>x</small></code><small> with </small><small>2</small><em><small>y</small></em><small>.</small></p><p><code>A </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">4</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">100</span></code><code> </code><code><span style="color:#2b2b2b;">(in</span></code><code> </code><code><span style="color:#569cd6;">binary</span></code><code><span style="color:#2b2b2b;">)</span></code><code> </code><code></code></p><p><code>A </code><code><span style="color:#2b2b2b;">&gt;&gt;</span></code><code> </code><code><span style="color:#b5cea8;">1</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">100</span></code><code> </code><code><span style="color:#2b2b2b;">&gt;&gt;</span></code><code> </code><code><span style="color:#b5cea8;">1</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">010</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">2</span></code><code> </code><code><span style="color:#2b2b2b;">(in</span></code><code> </code><code><span style="color:#569cd6;">decimal</span></code><code><span style="color:#2b2b2b;">)</span></code><code></code></p><p><code>A </code><code><span style="color:#2b2b2b;">&gt;&gt;</span></code><code> </code><code><span style="color:#b5cea8;">2</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">100</span></code><code> </code><code><span style="color:#2b2b2b;">&gt;&gt;</span></code><code> </code><code><span style="color:#b5cea8;">2</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">001</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">1</span></code><code> </code><code><span style="color:#2b2b2b;">(in</span></code><code> </code><code><span style="color:#569cd6;">decimal</span></code><code><span style="color:#2b2b2b;">)</span></code><code></code></p><p><code>A </code><code><span style="color:#2b2b2b;">&gt;&gt;</span></code><code> </code><code><span style="color:#b5cea8;">3</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">100</span></code><code> </code><code><span style="color:#2b2b2b;">&gt;&gt;</span></code><code> </code><code><span style="color:#b5cea8;">3</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">000</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">0</span></code><code> </code><code><span style="color:#2b2b2b;">(in</span></code><code> </code><code><span style="color:#569cd6;">decimal</span></code><code><span style="color:#2b2b2b;">)</span></code><code></code></p><p><code></code><code></code></p><p><code>B </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">5</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">00101</span></code><code> </code><code><span style="color:#2b2b2b;">(in</span></code><code> </code><code><span style="color:#569cd6;">binary</span></code><code><span style="color:#2b2b2b;">)</span></code><code></code></p><p><code>B </code><code><span style="color:#2b2b2b;">&gt;&gt;</span></code><code> </code><code><span style="color:#b5cea8;">1</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">00101</span></code><code> </code><code><span style="color:#2b2b2b;">&gt;&gt;</span></code><code> </code><code><span style="color:#b5cea8;">1</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">00010</span></code><code> </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#b5cea8;">2</span></code><code> </code><code><span style="color:#2b2b2b;">(in</span></code><code> </code><code><span style="color:#569cd6;">decimal</span></code><code><span style="color:#2b2b2b;">)</span></code></p><p></p><p></p><p></p><p></p><p></p><p></p><p><small>↓</small><small>Portion After Review​</small></p><p><small>Since the problem title is </small><strong><small>Single Number II</small></strong><small>, readers are advised to solve its prequel </small><a href="https://leetcode.com/problems/single-number/">Single Number</a><small> using constant space.</small></p><p>The Bit Manipulation approach of <a href="https://leetcode.com/problems/single-number">Single Number</a> primarily uses <strong>XOR</strong> operation. Click here for a detailed refresher on <strong>XOR</strong>.</p><p><strong><small>XOR</small></strong><small> is a bitwise operator. It takes two integers and returns an integer. It&#39;s denoted by </small><small>⊕</small><small>, and the symbol often used in programming languages is </small><code><small>^</small></code><small>.</small><small></small></p><p><small>The truth table of XOR is</small></p><p><table class="table"><tr><th>A</th><th>B</th><th>A ⊕ B</th></tr><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></table></p><p><small>It can be seen that the XOR of two bits is </small><small>1</small><small> only if the bits are different, otherwise, it is </small><small>0</small><small>.</small></p><p><small>In other words, </small><strong><small>XOR is modulo </small></strong><strong><small>2</small></strong><strong><small> addition</small></strong><small>.</small></p><p><em><small>A</small></em><small>⊕</small><em><small>B</small></em><small>=</small><em><small>A</small></em><em><small>B</small></em><small>ˉ</small><small>+</small><em><small>A</small></em><small>ˉ</small><em><small>B</small></em><small>​</small></p><p><em><small>A</small></em><small>⊕</small><em><small>B</small></em><small>=(</small><em><small>A</small></em><small>+</small><em><small>B</small></em><small>) mod 2​</small></p><p><strong><small>Properties of XOR</small></strong><ul><li><em><small>A</small></em><small>⊕</small><em><small>A</small></em><small>=0</small></li></ul><small></small></p><p><small>XOR of an integer with itself is </small><small>0</small><small>. Since an integer is composed of bits, thus all bits will be canceled out.</small></p><p><ul><li><em><small>A</small></em><small>⊕0=</small><em><small>A</small></em></li></ul><small></small></p><p><small>XOR of an integer with </small><small>0</small><small> is the integer itself.</small></p><p><ul><li><em><small>A</small></em><small>⊕</small><em><small>B</small></em><small>⊕</small><em><small>A</small></em><small>=(</small><em><small>A</small></em><small>⊕</small><em><small>A</small></em><small>)⊕</small><em><small>B</small></em><small>=0⊕</small><em><small>B</small></em><small>=</small><em><small>B</small></em></li></ul><small></small></p><p><small>XOR of an integer with itself and another integer is the other integer.</small></p><p><ul><li><small>XOR can be used to swap two numbers without using a third variable. Let two numbers be </small><em><small>A</small></em><small> and </small><em><small>B</small></em><small>.</small></li><li><em><small>A</small></em><small>=</small><em><small>A</small></em><small>⊕</small><em><small>B</small></em>, this will mix both <em><small>A</small></em> and <em><small>B</small></em> in <em><small>A</small></em>.</li><li><em><small>B</small></em><small>=</small><em><small>A</small></em><small>⊕</small><em><small>B</small></em>, Now, <em><small>A</small></em> was actually <em><small>A</small></em><small>⊕</small><em><small>B</small></em>, so <em><small>B</small></em><small>=(</small><em><small>A</small></em><small>⊕</small><em><small>B</small></em><small>)⊕</small><em><small>B</small></em><small>=</small><em><small>A</small></em><small>⊕(</small><em><small>B</small></em><small>⊕</small><em><small>B</small></em><small>)=</small><em><small>A</small></em><small>⊕0=</small><em><small>A</small></em>. Thus, <em><small>B</small></em> is now <em><small>A</small></em>.</li><li><em><small>A</small></em><small>=</small><em><small>A</small></em><small>⊕</small><em><small>B</small></em>, Now, <em><small>B</small></em> was made <em><small>A</small></em> in last step, so <em><small>A</small></em><small>=(</small><em><small>A</small></em><small>⊕</small><em><small>B</small></em><small>)⊕</small><em><small>A</small></em><small>=</small><em><small>B</small></em><small>⊕(</small><em><small>A</small></em><small>⊕</small><em><small>A</small></em><small>)=</small><em><small>B</small></em><small>⊕0=</small><em><small>B</small></em>. Thus, <em><small>A</small></em> is now original <em><small>B</small></em>.</li></ul></p><p></p><p></p><p></p><p></p><p></p><p><small>↓</small><small>Portion After Refresher​</small></p><p><small>The XOR-ing worked in </small><a href="https://leetcode.com/problems/single-number/">Single Number</a><small> because of this property</small></p><p><em><small>A</small></em><small>⊕</small><em><small>B</small></em><small>=(</small><em><small>A</small></em><small>+</small><em><small>B</small></em><small>) mod 2​</small></p><p><small>XOR is </small><strong><small>modulo </small></strong><strong><small>2</small></strong><strong><small> addition</small></strong><small>. In this problem, we are interested in </small><strong><small>modulo </small></strong><strong><small>3</small></strong><strong><small> addition</small></strong><small>.</small></p><p><strong><small>And why is that?</small></strong><small></small></p><p><small>Because, in the problem statement, it is given that all integers appear thrice except one. So, if we add all integers modulo </small><small>3</small><small>, then the integer which appears once will be left out.</small></p><p><strong>But do we have to add integers and take modulo 3? </strong>Ponder for a while. If done, reveal by clicking on this text.</p><p><small>Let&#39;s take the example of </small><code><small>nums</small></code><small> as </small><code><small>[5, 5, 5, 1]</small></code><small>. Their sum is </small><small>16</small><small>. If we take modulo </small><small>3</small><small>, then </small><small>16 mod 3=1</small><small>. And </small><small>1</small><small> is the loner.</small></p><p><small>But a quick counter-example is </small><code><small>[5, 5, 5, 4]</small></code><small>. Their sum is </small><small>19</small><small>. If we take modulo </small><small>3</small><small>, then </small><small>19 mod 3=1</small><small>. But loner is </small><small>4</small><small>.</small></p><p><small>So, thus, adding integers and taking modulo </small><small>3</small><small> is not the solution.</small></p><p><small>XOR does modulo </small><small>2</small><small> addition, but addition is performed bit-by-bit. Not on the whole integer. So, adding all bits at index </small><em><small>i</small></em><small> and taking modulo </small><small>2</small><small> will give us the </small><em><small>i</small></em><small>th</small><small> bit of the loner. Thus, we can find the loner bit by bit.</small></p><p><small>Taking inspiration from this, we can do modulo </small><small>3</small><small> addition bit-by-bit, by representing integers in binary.</small></p><p></p><p></p><p><small>↓</small><small>Portion After Revealing​</small></p><p><small>So, concluding, to compute the </small><em><small>i</small></em><small>th</small><small> bit of the loner, we can add the </small><em><small>i</small></em><small>th</small><small> bit of all integers and take modulo </small><small>3</small><small>. This will give us the </small><em><small>i</small></em><small>th</small><small> bit of the loner. We will do this for every bit, and thus, we will get the loner.</small></p><p><strong><small>How many bits do we have to iterate?</small></strong><small></small></p><p><small>For this, let&#39;s look at the constraints. It is given that </small><small>−2</small><small>31</small><small>≤nums[</small><em><small>i</small></em><small>]&lt;2</small><small>31</small><small>. Now, since integers can be negative, and different programming languages have different ways of representing negative integers, implementing this solution will be different for different languages. If we assume that negative integers are represented in </small><a href="https://en.wikipedia.org/wiki/Two%27s_complement">2&#39;s complement</a><small>, then the number of bits will be 32. So, we will iterate 32 times.</small></p><p><strong><small>How to get the </small></strong><em><strong><small>i</small></strong></em><strong><small>th</small></strong><strong><small> bit of an integer?</small></strong><small> Can we use any bitwise operator? Let&#39;s simplify</small></p><p><strong><small>How to get the </small></strong><strong><small>0</small></strong><strong><small>th</small></strong><strong><small> bit of an integer</small></strong><small>?</small><small></small></p><p><small>The </small><small>0</small><small>th</small><small> bit of an integer is the last bit of the binary representation of the integer, often called the </small><em><small>least significant bit</small></em><small>. To get the last bit of an integer, we can use the bitwise AND (</small><code><small>&amp;</small></code><small>) operator with </small><small>1</small><small>. This </small><small>1</small><small> is internally </small><code><small>0000....000001</small></code><small>. So, bit-wise AND-ing, due to its property of </small><em><small>x</small></em><small>&amp;0=0</small><small> will turn off all bits except the last bit. And due to the property of </small><em><small>x</small></em><small>&amp;1=</small><em><small>x</small></em><small>, the last bit will remain as it is. Thus, we will get the last bit of the integer.</small></p><p><small>So, if we want to get the </small><em><small>i</small></em><small>th</small><small> bit of an integer, we can right shift (</small><code><small>&gt;&gt;</small></code><small>) the integer by </small><em><small>i</small></em><small> bits, and then AND it with </small><small>1</small><small>. This will give us the </small><em><small>i</small></em><small>th</small><small> bit of the integer. Right shifting will bring the </small><em><small>i</small></em><small>th</small><small> bit to the </small><small>0</small><small>th</small><small> position, and then AND-ing with </small><small>1</small><small> will give us the </small><em><small>i</small></em><small>th</small><small> bit.</small></p><p><small>This in code, for </small><code><small>num</small></code><small> in </small><code><small>nums</small></code><small>, code will look like this</small></p><p><code>bit = </code><code><span style="color:#2b2b2b;">(</span></code><code>num &gt;&gt; shift</code><code><span style="color:#2b2b2b;">)</span></code><code> &amp; 1</code></p><p></p><p></p><p><small>where </small><code><small>shift</small></code><small> is the value of </small><em><small>i</small></em><small>. For a particular </small><code><small>shift</small></code><small>, we can iterate over all integers in </small><code><small>nums</small></code><small> and sum them to get the </small><em><small>i</small></em><small>th</small><small> bit of the loner.</small></p><p><small>Let </small><code><small>bitSum</small></code><small> be the sum of </small><em><small>i</small></em><small>th</small><small> bits of all integers in </small><code><small>nums</small></code><small>. Then, the </small><em><small>i</small></em><small>th</small><small> bit of the loner will be </small><code><small>bitSum % 3</small></code><small>. Note that because of problem constraints, </small><code><small>bitSum % 3</small></code><small> will be either </small><small>0</small><small> or </small><small>1</small><small>. All triplets would ultimately boil down to </small><small>0</small><small> after ADD-ing and MOD-ing. So, if </small><code><small>bitSum % 3</small></code><small> is </small><small>0</small><small>, it means that the </small><em><small>i</small></em><small>th</small><small> bit of the loner was not set. If it is </small><small>1</small><small>, it means that the </small><em><small>i</small></em><small>th</small><small> bit of the loner was set.</small></p><p><small>Now, let&#39;s have </small><code><small>lonerBit</small></code><small> store </small><code><small>bitSum % 3</small></code><small>.</small></p><p><strong><small>How to shift </small></strong><strong><code><small>lonerBit</small></code></strong><strong><small> to the </small></strong><em><strong><small>i</small></strong></em><strong><small>th</small></strong><strong><small> position?</small></strong><small></small></p><p><small>To compute, we right-shifted (</small><code><small>&gt;&gt;</small></code><small>) the integer by </small><em><small>i</small></em><small> bits. So, to shift it back to the </small><em><small>i</small></em><small>th</small><small> position, we left-shift (</small><code><small>&lt;&lt;</small></code><small>) it by </small><em><small>i</small></em><small> bits.</small></p><p><strong><small>And which operator can we use to place the </small></strong><em><strong><small>i</small></strong></em><strong><small>th</small></strong><strong><small> bit of the loner?</small></strong><small></small></p><p><small>We can use the bitwise OR (</small><code><small>|</small></code><small>) operator. The </small><small>0∣</small><em><small>x</small></em><small>=</small><em><small>x</small></em><small> property of bitwise OR will help here.</small></p><p><small>In code,</small></p><p><code>loner = loner | (lonerBit &lt;&lt; shift)</code></p><p></p><p></p><p><small>Readers can implement this solution in their preferred language.</small></p><p></p><p><h4>Algorithm</h4><ol><li><small>Initialize </small><code><small>loner</small></code><small> to </small><code><small>0</small></code></li></ol></p><p><ol><li><small>Using a for loop, iterate over all bits from </small><code><small>0</small></code><small> to </small><code><small>31</small></code><small> using the variable </small><code><small>shift</small></code><small>.</small></li><li><small>Initialize </small><code><small>bitSum</small></code><small> to </small><code><small>0</small></code></li></ol></p><p><ol><li><small>Using a for loop, iterate over all </small><code><small>num</small></code><small> in </small><code><small>nums</small></code></li><li><small>Compute </small><code><small>bit</small></code><small> as the </small><small>shift</small><small>th</small><small> bit of </small><code><small>num</small></code><small> using </small><code><small>bit = (num &gt;&gt; shift) &amp; 1</small></code><small>.</small></li></ol></p><p><ul><li><small>Add </small><code><small>bit</small></code><small> to </small><code><small>bitSum</small></code><small>.</small></li></ul></p><p></p><p></p><p><ul><li><small>Compute </small><code><small>lonerBit</small></code><small> as </small><code><small>bitSum % 3</small></code><small>.</small></li></ul></p><p><ul><li><small>Place the </small><small>shift</small><small>th</small><small> bit of </small><code><small>loner</small></code><small> as </small><code><small>loner = loner | (lonerBit &lt;&lt; shift)</small></code><small>.</small></li></ul></p><p></p><p><ul><li><small>Return </small><code><small>loner</small></code><small>.</small></li></ul></p><p></p><p></p><p><h4>Implementation</h4></p><p><strong><small>Implementation Notes</small></strong><ol><li><small>We can use this approach only if we know the range of integers in </small><code><small>nums</small></code><small>. For this, we need to find the maximum and minimum integers in </small><code><small>nums</small></code><small>. And find required bits to represent those integers by taking </small><small>log</small><small>2​</small><small> of those integers, keeping in mind the number system used to represent integers in machine/language.</small></li></ol></p><p><ol><li><small>This approach can also be used if instead of triplets, there are quadruplets, quintuplets, etc. We just need to change the </small><code><small>bitSum % 3</small></code><small> to </small><code><small>bitSum % k</small></code><small>, where </small><em><small>k</small></em><small> is the number of times each integer is repeated, provided there is exactly one loner.</small></li></ol></p><p><ol><li><small>Python doesn&#39;t have fixed-size integers, they are dynamically allocated. The interpreter doesn&#39;t know if the answer is constructed in 2&#39;s complement or not. In other words, it doesn&#39;t know if the leftmost set MSB is a sign bit or a value bit.</small></li></ol></p><p><small>Now, we know that the maximum value of </small><code><small>loner</small></code><small> is </small><small>2</small><small>31</small><small>−1</small><small>. So, if </small><code><small>loner</small></code><small> turns out to be more than this, it means that the leftmost set bit is a sign bit. So, we need to convert it to 2&#39;s complement. We can do this by subtracting </small><small>2</small><small>32</small><small> from </small><code><small>loner</small></code><small>. More can be read </small><a href="https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex">here</a><small>.</small></p><p></p><p><div class="codebox"><pre><span style="color:#ff9d00;font-weight:700">class</span> <span style="color:#333333;font-weight:400">Solution</span>:<br />    <span style="color:#ff9d00;font-weight:700">def</span> <span style="color:#333333;font-weight:400">singleNumber</span>(<span style="color:#333333;font-weight:400">self</span>, nums: List[<span style="color:#ff9d00;font-weight:700">int</span>]) -&gt; <span style="color:#ff9d00;font-weight:700">int</span>:<br /><br />        <span style="color:#0088ff;font-weight:400"># Loner.</span><br />        loner = <span style="color:#ff0044;font-weight:400">0</span><br /><br />        <span style="color:#0088ff;font-weight:400"># Iterate over all bits</span><br />        <span style="color:#ff9d00;font-weight:700">for</span> shift <span style="color:#ff9d00;font-weight:700">in</span> <span style="color:#ff9d00;font-weight:700">range</span>(<span style="color:#ff0044;font-weight:400">32</span>):<br />            bit_sum = <span style="color:#ff0044;font-weight:400">0</span><br /><br />            <span style="color:#0088ff;font-weight:400"># For this bit, iterate over all integers</span><br />            <span style="color:#ff9d00;font-weight:700">for</span> num <span style="color:#ff9d00;font-weight:700">in</span> nums:<br /><br />                <span style="color:#0088ff;font-weight:400"># Compute the bit of num, and add it to bit_sum</span><br />                bit_sum += (num &gt;&gt; shift) &amp; <span style="color:#ff0044;font-weight:400">1</span><br /><br />            <span style="color:#0088ff;font-weight:400"># Compute the bit of loner and place it</span><br />            loner_bit = bit_sum % <span style="color:#ff0044;font-weight:400">3</span><br />            loner = loner | (loner_bit &lt;&lt; shift)<br /><br />        <span style="color:#0088ff;font-weight:400"># Do not mistaken sign bit for MSB.</span><br />        <span style="color:#ff9d00;font-weight:700">if</span> loner &gt;= (<span style="color:#ff0044;font-weight:400">1</span> &lt;&lt; <span style="color:#ff0044;font-weight:400">31</span>):<br />            loner = loner - (<span style="color:#ff0044;font-weight:400">1</span> &lt;&lt; <span style="color:#ff0044;font-weight:400">32</span>)<br /><br />        <span style="color:#ff9d00;font-weight:700">return</span> loner</pre></div></p><p></p><p><h4>Complexity Analysis</h4></p><p><small>Let </small><em><small>N</small></em><small> be the length of </small><code><small>nums</small></code><ul><li><small>Time complexity: </small><em><small>O</small></em><small>(</small><em><small>N</small></em><small>)</small></li></ul></p><p><small>We iterate over all integers in </small><code><small>nums</small></code><small> once, and for each integer, we iterate over all 32 bits. So, the time complexity is </small><em><small>O</small></em><small>(32</small><em><small>N</small></em><small>)</small><small>, which is </small><em><small>O</small></em><small>(</small><em><small>N</small></em><small>)</small><small>.</small></p><p><ul><li><small>Space complexity: </small><em><small>O</small></em><small>(1)</small></li></ul></p><p><small>We use constant extra space, with fixed-size variables. So, the space complexity is </small><em><small>O</small></em><small>(1)</small><small>.</small></p><p></p><p></p><p><strong><small>Note:</small></strong><small> Reader may comment that time complexity is </small><em><small>O</small></em><small>(</small><em><small>N</small></em><small>log</small><em><small>N</small></em><small>)</small><small> because we are iterating the number of times equal to the number of bits in an integer. However, our code is designed in such a way that it will iterate only 32 times, which is constant. So, the time complexity is </small><em><small>O</small></em><small>(</small><em><small>N</small></em><small>)</small><small>. The </small><small>log</small><em><small>N</small></em><small> factor will not be counted because of our design. We were able to design it because of some pre-knowledge of the problem.</small></p><p></p><p><h3></h3></p><p><h3></h3><h3>Approach 5: Equation for Bitmask</h3></p><p></p><p><h4>Intuition</h4></p><p><small>The drawback of </small><a href="https://leetcode.com/problems/single-number-ii/editorial/?envType=study-plan-v2&envId=top-interview-150#approach-4-bit-manipulation">Approach 4</a><small> was that we somewhat hard-coded it for 32-bit integers. Let&#39;s move towards a more generic solution.</small></p><p><em><strong><small>Note:</small></strong></em><em><small> This approach can be labeled as Advanced. Don&#39;t be discouraged if you aren&#39;t able to come up with it yourself. But make sure you read this approach.</small></em></p><p><small>Before reading this approach, make sure you</small></p><p><small>✔ are well-versed in the basics of Bit Manipulation. A quick refresher is given in </small><a href="https://leetcode.com/problems/single-number-ii/editorial/?envType=study-plan-v2&envId=top-interview-150#approach-4-bit-manipulation">intuition of Approach 4</a><small>.</small><small></small></p><p><small>✔ have an idea how bit-manipulation was used in </small><a href="https://leetcode.com/problems/single-number/">Single Number</a><small>.</small></p><p><small>XOR could be used to detect the bit which appears an odd number of times. In other words, </small><em><small>we can see a bit in a bitmask only if it appears an odd number of times.</small></em><small> The following equation is at the heart of the XOR operation which we exhausted in </small><a href="https://leetcode.com/problems/single-number/">Single Number</a><small>.</small></p><p><em><small>A</small></em><small>⊕</small><em><small>B</small></em><small>=</small><em><small>A</small></em><em><small>B</small></em><small>ˉ</small><small>+</small><em><small>A</small></em><small>ˉ</small><em><small>B</small></em><small>​</small></p><p><strong><small>Can we logically derive a similar equation for bitmask for this problem?</small></strong></p><p><small>Here, </small><em><small>we want to see a bit in a bitmask only if it appears </small></em><em><small>1</small></em><em><small> time</small></em><small>. More precisely,</small><ul><li><small>If an integer appears </small><small>3</small><small> times, it should not be seen in the bitmask.</small></li></ul></p><p><ul><li><small>If an integer appears </small><small>1</small><small> time, it should be seen in the bitmask.</small></li></ul></p><p><ul><li><small>If an integer appears </small><small>2</small><small> times, it should not be seen in the bitmask, however, we need not worry about it because problem description guarantees no such case will be there.</small></li></ul></p><p></p><p></p><p><small>As XOR does modulo </small><small>2</small><small>, we need to find a similar operation that does modulo </small><small>3</small><small>. For this, let&#39;s have a few bitmasks such as </small><code><small>seenZero</small></code><small>, </small><code><small>seenOnce</small></code><small>, and </small><code><small>seenTwice</small></code><small>.</small><ul><li><small>If any bit in </small><code><small>seenZero</small></code><small> is set, it means that bit has appeared </small><small>0</small><small> times in all integers seen so far. Since we are doing modulo </small><small>3</small><small>, this </small><code><small>seenZero</small></code><small> can also be interpreted as </small><code><small>seenThrice</small></code><small>. In other words, if a bit is set in </small><code><small>seenZero</small></code><small>, it can be the case that it has appeared multiple of </small><small>3</small><small> times.</small></li></ul></p><p><ul><li><small>If any bit in </small><code><small>seenOnce</small></code><small> is set, it means that bit has appeared </small><small>1 (mod 3)</small><small> times in all integers seen so far.</small></li></ul></p><p><ul><li><small>If any bit in </small><code><small>seenTwice</small></code><small> is set, it means that bit has appeared </small><small>2 (mod 3)</small><small> times in all integers seen so far.</small></li></ul></p><p></p><p></p><p><small>Initially, no integer has been seen, so both </small><code><small>seenOnce</small></code><small> and </small><code><small>seenTwice</small></code><small> are initialized to </small><small>0</small><small>. </small><code><small>seenZero</small></code><small> will be initialized to </small><small>1111…1111</small><small> (all bits set to </small><small>1</small><small>), because all bits have been seen </small><small>0</small><small> times, initially.</small></p><p><strong><small>Do we really need </small></strong><strong><code><small>seenZero</small></code></strong><strong><small>?</small></strong><small></small></p><p><small>Turns out, we don&#39;t need </small><code><small>seenZero</small></code><small>. We can use </small><code><small>seenOnce</small></code><small> and </small><code><small>seenTwice</small></code><small> to represent </small><code><small>seenZero</small></code><small>. In other words, if a bit is not set in </small><code><small>seenOnce</small></code><small>, and not set in </small><code><small>seenTwice</small></code><small>, then it must be set in </small><code><small>seenZero</small></code><small>. This is because we must have seen it </small><small>0 (mod 3)</small><small> times.</small></p><p><small>Note that </small><em><small>i</small></em><small>th</small><small> bit will be set in ONE AND ONLY ONE among </small><code><small>seenOnce</small></code><small>, </small><code><small>seenTwice</small></code><small>, or trivially </small><code><small>seenZero</small></code><small>.</small></p><p><small>Now, let&#39;s say we have an integer </small><code><small>num</small></code><small> in </small><code><small>nums</small></code><small>. We need to update </small><code><small>seenOnce</small></code><small> and </small><code><small>seenTwice</small></code><small> accordingly. Let&#39;s try to derive equations.</small><ul><li><small>For </small><code><small>seenOnce</small></code><small>,</small></li><li><small>It should not be previously seen twice. So, </small><code><small>seenTwice</small></code><small> should not be set at that bit.</small></li></ul></p><p><ul><li><small>If it was previously seen once, then it should be removed from </small><code><small>seenOnce</small></code><small>. If not, then it should be added to </small><code><small>seenOnce</small></code><small>. This can be done by XORing </small><code><small>seenOnce</small></code><small> with </small><code><small>num</small></code><small>. Either of them should be set, but not both. So, we can use XOR. In detail, if bit </small><code><small>b</small></code></li><li><small>is </small><code><small>0</small></code><small> in </small><code><small>num</small></code><small> and </small><code><small>0</small></code><small> in </small><code><small>seenOnce</small></code><small>, then </small><code><small>b</small></code><small> should be </small><code><small>0</small></code><small> in </small><code><small>seenOnce</small></code><small>, because we still haven&#39;t seen </small><code><small>b</small></code><small> in </small><code><small>num</small></code><small>.</small></li></ul></p><p><ul><li><small>is </small><code><small>1</small></code><small> in </small><code><small>num</small></code><small> and </small><code><small>0</small></code><small> in </small><code><small>seenOnce</small></code><small>, then </small><code><small>b</small></code><small> should be </small><code><small>1</small></code><small> in </small><code><small>seenOnce</small></code><small>, because we have seen </small><code><small>b</small></code><small> in </small><code><small>num</small></code><small>.</small></li></ul></p><p><ul><li><small>is </small><code><small>0</small></code><small> in </small><code><small>num</small></code><small> and </small><code><small>1</small></code><small> in </small><code><small>seenOnce</small></code><small>, then </small><code><small>b</small></code><small> should be </small><code><small>1</small></code><small>. This is because although we haven&#39;t seen </small><code><small>b</small></code><small> in </small><code><small>num</small></code><small>, we have seen it previously, so it should be set.</small></li></ul></p><p><ul><li><small>is </small><code><small>1</small></code><small> in </small><code><small>num</small></code><small> and </small><code><small>1</small></code><small> in </small><code><small>seenOnce</small></code><small>, then </small><code><small>b</small></code><small> should be </small><code><small>0</small></code><small>. This is because we have seen </small><code><small>b</small></code><small> twice, so it should be removed from </small><code><small>seenOnce</small></code><small>.</small></li></ul></p><p></p><p></p><p></p><p></p><p><small>Hence, the equation for </small><code><small>seenOnce</small></code><small> is</small></p><p><code>seenOnce = </code><code><span style="color:#2b2b2b;">(</span></code><code>seenOnce XOR num</code><code><span style="color:#2b2b2b;">)</span></code><code> AND </code><code><span style="color:#2b2b2b;">(</span></code><code>NOT seenTwice</code><code><span style="color:#2b2b2b;">)</span></code></p><p></p><p></p><p><ul><li><small>For </small><code><small>seenTwice</small></code></li><li><small>It should be previously seen once. So, </small><code><small>seenOnce</small></code><small> should be set at that bit. </small><strong><small>But, if we have ALREADY updated </small></strong><strong><code><small>seenOnce</small></code></strong><strong><small> for this </small></strong><strong><code><small>num</small></code></strong><strong><small> then, it should not be in </small></strong><strong><code><small>seenOnce</small></code></strong><small>. If the bit was set in </small><code><small>seenOnce</small></code><small>, then for this </small><code><small>num</small></code><small>, it was its first occurrence, and it should not be mistaken for a second occurrence.</small></li></ul></p><p><small>In other words, for the second occurrence, it must be removed from </small><code><small>seenOnce</small></code><small> while updating it using the </small><code><small>seenOnce</small></code><small> equation. Thus, it should NOT be in </small><code><small>seenOnce</small></code><small> while updating </small><code><small>seenTwice</small></code><small>.</small></p><p><ul><li><small>If it was previously seen twice, then it should be removed from </small><code><small>seenTwice</small></code><small>. If not, then it should be added to </small><code><small>seenTwice</small></code><small>. This can be done by XORing </small><code><small>seenTwice</small></code><small> with </small><code><small>num</small></code><small>. Either of them should be set, but not both. So, we can use XOR. In detail, if bit </small><code><small>b</small></code></li><li><small>is </small><code><small>0</small></code><small> in </small><code><small>num</small></code><small> and </small><code><small>0</small></code><small> in </small><code><small>seenTwice</small></code><small>, then </small><code><small>b</small></code><small> should be </small><code><small>0</small></code><small> in </small><code><small>seenTwice</small></code><small>, because we still haven&#39;t seen </small><code><small>b</small></code><small> in </small><code><small>num</small></code><small>.</small></li></ul></p><p><ul><li><small>is </small><code><small>1</small></code><small> in </small><code><small>num</small></code><small> and </small><code><small>0</small></code><small> in </small><code><small>seenTwice</small></code><small>, then </small><code><small>b</small></code><small> should be </small><code><small>1</small></code><small> in </small><code><small>seenTwice</small></code><small>. This we are doing because the bit was not set in </small><code><small>seenOnce</small></code><small>, which implies that even after having </small><code><small>1</small></code><small> in </small><code><small>num</small></code><small>, </small><code><small>seenOnce</small></code><small> was NOT set at that bit, this must be because it was previously set at that bit, and removed because of </small><code><small>1 XOR 1</small></code><small> update of </small><code><small>seenOnce</small></code><small>. Thus, this must be the second occurrence of </small><code><small>b</small></code><small>.</small></li></ul></p><p><ul><li><small>is </small><code><small>0</small></code><small> in </small><code><small>num</small></code><small> and </small><code><small>1</small></code><small> in </small><code><small>seenTwice</small></code><small>, then </small><code><small>b</small></code><small> should be </small><code><small>1</small></code><small>. This is because although we haven&#39;t seen </small><code><small>b</small></code><small> in </small><code><small>num</small></code><small>, we have seen it previously, so it should be set.</small></li></ul></p><p><ul><li><small>is </small><code><small>1</small></code><small> in </small><code><small>num</small></code><small> and </small><code><small>1</small></code><small> in </small><code><small>seenTwice</small></code><small>, then </small><code><small>b</small></code><small> should be </small><code><small>0</small></code><small>. This is because we have seen </small><code><small>b</small></code><small> twice, so it should be removed from </small><code><small>seenTwice</small></code><small>.</small></li></ul></p><p></p><p></p><p></p><p></p><p><small>The equation for </small><code><small>seenTwice</small></code><small> is</small></p><p><code>seenTwice = </code><code><span style="color:#2b2b2b;">(</span></code><code>seenTwice XOR num</code><code><span style="color:#2b2b2b;">)</span></code><code> AND </code><code><span style="color:#2b2b2b;">(</span></code><code>NOT seenOnce</code><code><span style="color:#2b2b2b;">)</span></code></p><p></p><p></p><p><small>The </small><code><small>seenOnce</small></code><small> on RHS of this equation is the </small><strong><small>updated </small></strong><strong><code><small>seenOnce</small></code></strong><small> after analysis of </small><code><small>num</small></code><small> on the </small><code><small>seenOnce</small></code><small> bitmask.</small></p><p></p><p></p><p><small>The crux of the approach is</small><ul><li><small>If a bit appears the first time, add it to </small><code><small>seenOnce</small></code><small>. It will not be added to </small><code><small>seenTwice</small></code><small> because of it&#39;s presence in </small><code><small>seenOnce</small></code><small>.</small></li></ul></p><p><ul><li><small>If a bit appears a second time, remove it from </small><code><small>seenOnce</small></code><small> and add it to </small><code><small>seenTwice</small></code><small>.</small></li></ul></p><p><ul><li><small>If a bit appears a third time, it won&#39;t be added to </small><code><small>seenOnce</small></code><small> because it is already present in </small><code><small>seenTwice</small></code><small>. After that it will be removed from </small><code><small>seenTwice</small></code><small>.</small></li></ul></p><p></p><p></p><p><small>The derived equations are just a way to implement this logic.</small></p><p><small>Thus, after we are done traversing </small><code><small>nums</small></code><small>, we will have </small><code><small>seenOnce</small></code><small> set at all bits which are set in </small><code><small>nums</small></code><small> exactly once. This is what we wanted. So, we return </small><code><small>seenOnce</small></code><small> as the answer.</small></p><p><small>As a note, </small><code><small>seenTwo</small></code><small> will be </small><code><small>0</small></code><small> at the end, because problem constraints guarantee that there will be no integer that appears </small><small>2 (mod 3)</small><small> times.</small></p><p></p><p><h4>Algorithm</h4><ol><li><small>Initialize </small><code><small>seenOnce</small></code><small> and </small><code><small>seenTwice</small></code><small> to </small><code><small>0</small></code><small>.</small></li></ol></p><p><ol><li><small>Iterate through </small><code><small>nums</small></code><small> and update </small><code><small>seenOnce</small></code><small> and </small><code><small>seenTwice</small></code><small> using derived equations. Let </small><code><small>num</small></code><small> be the current integer.</small></li><li><code><small>seenOnce = (seenOnce ^ num) &amp; (~seenTwice)</small></code><small>: Update </small><code><small>seenOnce</small></code><small> using </small><code><small>num</small></code><small>. If </small><code><small>num</small></code><small> was previously seen once, then it will be removed from </small><code><small>seenOnce</small></code><small>. If not, then it will be added to </small><code><small>seenOnce</small></code><small>.</small></li></ol></p><p><ul><li><code><small>seenTwice = (seenTwice ^ num) &amp; (~seenOnce)</small></code><small>: Update </small><code><small>seenTwice</small></code><small> using </small><code><small>num</small></code><small>. If </small><code><small>num</small></code><small> was previously seen twice, then it will be removed from </small><code><small>seenTwice</small></code><small>. If not, then it will be added to </small><code><small>seenTwice</small></code><small>.</small></li></ul></p><p></p><p></p><p><ul><li><small>Return </small><code><small>seenOnce</small></code><small> as the answer.</small></li></ul></p><p></p><p></p><p><h4>Implementation</h4></p><p><strong><small>Implementation Notes:</small></strong><small> Different programming languages have different notations of bitwise operators. For example, for the bitwise NOT operator, we have the following notations:</small><ul><li><a href="https://en.cppreference.com/w/cpp/language/operator_arithmetic">C++</a> uses <code>~</code></li><li><a href="https://go.dev/ref/spec">Go</a> uses unary <code>^</code> operator</li><li><a href="https://hexdocs.pm/elixir/1.13.0/Bitwise.html">Elixir</a> uses <code>~~~</code>, or <code>bnot</code></li><li><a href="https://doc.rust-lang.org/book/appendix-02-operators.html">Rust</a> uses <code>!</code></li><li>In <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/inv.html">Kotlin</a>, we can use <code>inv()</code> function</li></ul></p><p></p><p><small>The </small><a href="https://leetcode.com/problems/single-number-ii/editorial/?envType=study-plan-v2&envId=top-interview-150#approach-2-hash-map">counter</a><small> approach was not feasible in C programming language because it does not support hash maps. We may augment the array to represent integers using indices, and frequency using value at those indices. However, </small><small>[−2</small><small>31</small><small>,2</small><small>31</small><small>−1]</small><small> range of integers demands a huge array of size </small><small>2</small><small>32</small><small>, which is not feasible in practice.</small></p><p><small>On the other hand, this approach is quite feasible and hence can be implemented in most programming languages if they support basic programming constructs such as variables, loops, and bitwise operators. That&#39;s why the above implementation includes most of the programming languages supported by LeetCode.</small></p><p></p><p><div class="codebox"><pre><span style="color:#ff9d00;font-weight:700">class</span> <span style="color:#333333;font-weight:400">Solution</span>:<br />    <span style="color:#ff9d00;font-weight:700">def</span> <span style="color:#333333;font-weight:400">singleNumber</span>(<span style="color:#333333;font-weight:400">self</span>, nums: List[<span style="color:#ff9d00;font-weight:700">int</span>]) -&gt; <span style="color:#ff9d00;font-weight:700">int</span>:<br /><br />        <span style="color:#0088ff;font-weight:400"># Initialize seen_once and seen_twice to 0</span><br />        seen_once = seen_twice = <span style="color:#ff0044;font-weight:400">0</span><br /><br />        <span style="color:#0088ff;font-weight:400"># Iterate through nums</span><br />        <span style="color:#ff9d00;font-weight:700">for</span> num <span style="color:#ff9d00;font-weight:700">in</span> nums:<br />            <span style="color:#0088ff;font-weight:400"># Update using derived equations</span><br />            seen_once = (seen_once ^ num) &amp; (~seen_twice)<br />            seen_twice = (seen_twice ^ num) &amp; (~seen_once)<br /><br />        <span style="color:#0088ff;font-weight:400"># Return integer which appears exactly once</span><br />        <span style="color:#ff9d00;font-weight:700">return</span> seen_once</pre></div></p><p></p><p><h4>Complexity Analysis</h4></p><p><small>Let </small><em><small>N</small></em><small> be the length of </small><code><small>nums</small></code><ul><li><small>Time complexity: </small><em><small>O</small></em><small>(</small><em><small>N</small></em><small>)</small></li><li><small>We iterate through </small><code><small>nums</small></code><small> once.</small></li></ul></p><p><ul><li><small>For each integer, we update </small><code><small>seenOnce</small></code><small> and </small><code><small>seenTwice</small></code><small> using derived equations. This takes constant time.</small></li></ul></p><p></p><p></p><p><small>Thus, for one </small><code><small>num</small></code><small>, we take constant time. For </small><em><small>N</small></em><small> </small><code><small>nums</small></code><small>, we take </small><em><small>O</small></em><small>(</small><em><small>N</small></em><small>)</small><small> time.</small></p><p><ul><li><small>Space complexity: </small><em><small>O</small></em><small>(1)</small></li></ul></p><p><small>We use constant extra space for </small><code><small>seenOnce</small></code><small> and </small><code><small>seenTwice</small></code><small>.</small></p><p></p><p></p><p></p><p><h3></h3></p><p><h3></h3><h3>Approach 6: Boolean Algebra and Karnaugh Map</h3></p><p></p><p><h4>Intuition</h4></p><p><small>This approach is interesting and uses the core courses which some readers might have completed during their education. The courses are broadly known as</small></p><p><small>🎓 Discrete Mathematics (particularly Boolean Algebra)</small><small></small></p><p><small>🎓 Digital Logic Design (particularly Karnaugh Map)</small><small></small></p><p><small>🎓 Theory of Automata (especially Finite State Machines)</small></p><p><small>Even if readers haven&#39;t completed these courses, they can still understand the approach.</small></p><p><small>We will do what we are doing from </small><a href="https://leetcode.com/problems/single-number-ii/editorial/?envType=study-plan-v2&envId=top-interview-150#approach-4-bit-manipulation">Approach 4</a><small> onwards. </small><strong><small>Count the number of </small></strong><strong><code><small>1</small></code></strong><strong><small> bits (mod 3) at each bit position</small></strong><small>. For this, assume we have counted the number of set bits, </small><code><small>count</small></code><small> at a particular bit position. Then, </small><code><small>count</small></code><small> can be </small><small>0</small><small>, </small><small>1</small><small>, or </small><small>2</small><small>. If we encounter another integer with </small><code><small>1</small></code><small> at this bit position, then </small><code><small>count</small></code><small> will be modified to </small><small>1</small><small>, </small><small>2</small><small>, or </small><small>0</small><small> respectively.</small></p><p><small>Thus, the </small><code><small>count</small></code><small> cycle will work as</small></p><p><small>0→1→2→0→1…→0→1→2→0→1…</small></p><p><small>We need to store the count in binary form. For mapping three states (</small><small>0</small><small>, </small><small>1</small><small>, and </small><small>2</small><small>) to binary form, we need at least 2 bits. Let the mapping be</small><ul><li><small>0→</small> <code>00</code></li><li><small>1→</small> <code>01</code></li><li><small>2→</small> <code>10</code></li></ul></p><p></p><p><small>The </small><code><small>count</small></code><small> cycle will be modified as</small></p><p><code><small>00</small></code><small> </small><small>→</small><small> </small><code><small>01</small></code><small> </small><small>→</small><small> </small><code><small>10</small></code><small> </small><small>→</small><small> </small><code><small>00</small></code><small> </small><small>→</small><small> </small><code><small>01</small></code><small> </small><small>…</small><small> </small><small>→</small><small> </small><code><small>00</small></code><small> </small><small>→</small><small> </small><code><small>01</small></code><small> </small><small>→</small><small> </small><code><small>10</small></code><small> </small><small>→</small><small> </small><code><small>00</small></code><small> </small><small>→…</small></p><p><small>Note that </small><strong><small>cycle will proceed only if we encounter </small></strong><strong><code><small>1</small></code></strong><strong><small> at this bit position</small></strong><small>. If we encounter </small><code><small>0</small></code><small>, then the </small><code><small>count</small></code><small> should remain the same.</small></p><p><strong><small>So, how many input states do we have?</small></strong><small></small></p><p><small>We have 1 input bit from </small><code><small>num</small></code><small> and 2 input bits from </small><code><small>count</small></code><small>. Thus, we have 3 input bits. Let the </small><code><small>count</small></code><small> bit be represented as </small><code><small>msb</small></code><small> and </small><code><small>lsb</small></code><small>. They stand for </small><strong><small>m</small></strong><small>ost </small><strong><small>s</small></strong><small>ignificant </small><strong><small>b</small></strong><small>it and </small><strong><small>l</small></strong><small>east </small><strong><small>s</small></strong><small>ignificant </small><strong><small>b</small></strong><small>it respectively. Let the bit of </small><code><small>num</small></code><small> be represented as </small><code><small>numBit</small></code><small>.</small></p><p><strong><small>In how many output states are we interested?</small></strong><small></small></p><p><small>We are interested in 2 output states, namely </small><code><small>new_msb</small></code><small> and </small><code><small>new_lsb</small></code><small>.</small></p><p><small>Now, let&#39;s map the input states to the output states. Since we have </small><small>3</small><small> input </small><strong><small>BI</small></strong><small>-TS, we will have </small><small>2</small><small>3</small><small>=8</small><small> input states. Following is the truth table for the same.</small></p><p></p><p></p><p><small>We now have to map the output states to the input states. We can use </small><a href="https://en.wikipedia.org/wiki/Karnaugh_map">Karnaugh Map</a><small> for the same.</small></p><p><small>Karnaugh map refers to a pictorial method that is utilized to minimize various boolean expressions without using the boolean algebra theorems. In this problem, we will use the Karnaugh map to derive the equations for </small><code><small>new_msb</small></code><small> and </small><code><small>new_lsb</small></code><small> from the truth table.</small></p><p><small>The animation will derive the equation for </small><code><small>new_msb</small></code><small>. It assumes that readers are familiar with Karnaugh Map. If not, they can read about it </small><a href="https://en.wikipedia.org/wiki/Karnaugh_map">here</a><small>.</small></p><p><strong><small>Deriving equation for </small></strong><strong><code><small>new_msb</small></code></strong></p><p></p><p></p><p></p><p></p><p></p><p>1 / 21</p><p></p><p></p><p></p><p><small>Therefore,</small></p><p><code><small>new_msb = (lsb &amp; numBit) | (msb &amp; ~numBit)</small></code></p><p>Replicating similar steps, readers can derive equation for <code>new_lsb</code>. To verify the equation, click here.</p><p><small></small></p><p><small></small></p><p></p><p></p><p><small>↓</small><small>Portion after Answer Revelation​</small></p><p></p><p></p><p><small>So, we have derived two equations</small><ol><li><code>new_lsb = (~msb &amp; ~lsb &amp; numBit) | (lsb &amp; ~numBit)</code></li><li><code>new_msb = (lsb &amp; numBit) | (msb &amp; ~numBit)</code></li></ol></p><p><small>This is for all </small><code><small>numBit</small></code><small>. Thus, for </small><code><small>num</small></code><small> (an integer) in </small><code><small>nums</small></code><small> (an array), we can write</small><ol><li><code>new_lsb = (~msb &amp; ~lsb &amp; num) | (lsb &amp; ~num)</code></li><li><code>new_msb = (lsb &amp; num) | (msb &amp; ~num)</code></li></ol></p><p><small>After processing the current </small><code><small>num</small></code><small>, we have to update </small><code><small>msb</small></code><small> and </small><code><small>lsb</small></code><small> for the next iteration. We can do that as</small><ul><li><code>lsb = new_lsb</code></li><li><code>msb = new_msb</code></li></ul></p><p></p><p><small>After doing this for all </small><code><small>num</small></code><small> in </small><code><small>nums</small></code><small>, we want all those bits having </small><code><small>count</small></code><small> as </small><small>1</small><small>. This </small><code><small>count</small></code><small> was stored in the </small><code><small>msb-lsb</small></code><small> duo. For </small><small>1</small><small>, the state was </small><code><small>msb = 0</small></code><small> and </small><code><small>lsb = 1</small></code><small>.</small></p><p><small>So, we have to return all those bits where </small><code><small>msb</small></code><small> was 0, and </small><code><small>lsb</small></code><small> was 1. However, </small><code><small>lsb</small></code><small> as 1 guarantees that </small><code><small>msb</small></code><small> was 0 because 1-1 was an invalid state. So, we can return all those bits where </small><code><small>lsb</small></code><small> was 1.</small></p><p></p><p><h4>Algorithm</h4><ol><li><small>Initialize </small><code><small>msb</small></code><small> and </small><code><small>lsb</small></code><small> as </small><code><small>0</small></code><small>. This represents the initial state of </small><code><small>count</small></code><small> (mod </small><small>3</small><small>) as </small><small>0</small><small>.</small></li></ol></p><p><ol><li><small>Iterate over all </small><code><small>num</small></code><small> in </small><code><small>nums</small></code></li><li><small>Compute </small><code><small>new_lsb</small></code><small> and </small><code><small>new_msb</small></code><small> using the equations.</small></li><li><code><small>new_lsb = (~msb &amp; ~lsb &amp; num) | (lsb &amp; ~num)</small></code></li></ol></p><p><ul><li><code><small>new_msb = (lsb &amp; num) | (msb &amp; ~num)</small></code></li></ul></p><p></p><p></p><p><ul><li><small>Update </small><code><small>msb</small></code><small> and </small><code><small>lsb</small></code><small> as </small><code><small>new_msb</small></code><small> and </small><code><small>new_lsb</small></code><small> respectively.</small></li></ul></p><p></p><p></p><p><ul><li><small>Return </small><code><small>lsb</small></code><small> as the answer. It represents the bits where </small><code><small>count</small></code><small> (mod </small><small>3</small><small>) was </small><small>1</small><small>.</small></li></ul></p><p></p><p></p><p><h4>Implementation</h4></p><p><strong><small>Implementation Note:</small></strong><small> In Python, we can compact the four lines inside the </small><code><small>for</small></code><small> loop into a single line as</small></p><p>Python3</p><p></p><p><code>lsb</code><code><span style="color:#2b2b2b;">,</span></code><code> msb </code><code><span style="color:#2b2b2b;">=</span></code><code> </code><code><span style="color:#2b2b2b;">(~</span></code><code>msb </code><code><span style="color:#2b2b2b;">&amp;</span></code><code> </code><code><span style="color:#2b2b2b;">~</span></code><code>lsb </code><code><span style="color:#2b2b2b;">&amp;</span></code><code> num</code><code><span style="color:#2b2b2b;">)</span></code><code> </code><code><span style="color:#2b2b2b;">|</span></code><code> </code><code><span style="color:#2b2b2b;">(</span></code><code>lsb </code><code><span style="color:#2b2b2b;">&amp;</span></code><code> </code><code><span style="color:#2b2b2b;">~</span></code><code>num</code><code><span style="color:#2b2b2b;">),</span></code><code> </code><code><span style="color:#2b2b2b;">(</span></code><code>lsb </code><code><span style="color:#2b2b2b;">&amp;</span></code><code> num</code><code><span style="color:#2b2b2b;">)</span></code><code> </code><code><span style="color:#2b2b2b;">|</span></code><code> </code><code><span style="color:#2b2b2b;">(</span></code><code>msb </code><code><span style="color:#2b2b2b;">&amp;</span></code><code> </code><code><span style="color:#2b2b2b;">~</span></code><code>num</code><code><span style="color:#2b2b2b;">)</span></code></p><p></p><p><div class="codebox"><pre><span style="color:#ff9d00;font-weight:700">class</span> <span style="color:#333333;font-weight:400">Solution</span>:<br />    <span style="color:#ff9d00;font-weight:700">def</span> <span style="color:#333333;font-weight:400">singleNumber</span>(<span style="color:#333333;font-weight:400">self</span>, nums: List[<span style="color:#ff9d00;font-weight:700">int</span>]) -&gt; <span style="color:#ff9d00;font-weight:700">int</span>:<br /><br />        <span style="color:#0088ff;font-weight:400"># Count (modulo 3) bits</span><br />        msb, lsb = <span style="color:#ff0044;font-weight:400">0</span>, <span style="color:#ff0044;font-weight:400">0</span><br /><br />        <span style="color:#0088ff;font-weight:400"># Process Every Num and update count bits</span><br />        <span style="color:#ff9d00;font-weight:700">for</span> num <span style="color:#ff9d00;font-weight:700">in</span> nums:<br />            new_lsb = (~msb &amp; ~lsb &amp; num) | (lsb &amp; ~num)<br />            new_msb = (lsb &amp; num) | (msb &amp; ~num)<br />            lsb = new_lsb<br />            msb = new_msb<br /><br />        <span style="color:#0088ff;font-weight:400"># Return lsb as the answer</span><br />        <span style="color:#ff9d00;font-weight:700">return</span> lsb</pre></div></p><p></p><p><small>This is because Python evaluates the right-hand side of the assignment operator first and then assigns the values to the left-hand side. So, the values of </small><code><small>msb</small></code><small> and </small><code><small>lsb</small></code><small> are not changed while evaluating the right-hand side.</small></p><p></p><p><h4>Complexity Analysis</h4></p><p><small>Let </small><em><small>N</small></em><small> be the length of </small><code><small>nums</small></code><ul><li><small>Time complexity: </small><em><small>O</small></em><small>(</small><em><small>N</small></em><small>)</small></li></ul></p><p><small>We iterate over all </small><code><small>num</small></code><small> in </small><code><small>nums</small></code><small> once. During each iteration, we do constant time operations of updating </small><code><small>msb</small></code><small> and </small><code><small>lsb</small></code><small>. So, the total time complexity is </small><em><small>O</small></em><small>(</small><em><small>N</small></em><small>)</small></p><p><ul><li><small>Space complexity: </small><em><small>O</small></em><small>(1)</small></li></ul></p><p><small>We use constant space for </small><code><small>msb</small></code><small> and </small><code><small>lsb</small></code><small> to store count. So, total space complexity is </small><em><small>O</small></em><small>(1)</small></p><p></p><p></p><p></p><p><h3></h3></p><p><h3></h3><h3>Relation Between Approach 5 and Approach 6</h3></p><p>With tedious derivations, we can show that <a href="https://leetcode.com/problems/single-number-ii/editorial/?envType=study-plan-v2&envId=top-interview-150#approach-5-equation-for-bitmask">Approach 5</a> and <a href="https://leetcode.com/problems/single-number-ii/editorial/?envType=study-plan-v2&envId=top-interview-150#approach-6-boolean-algebra-and-karnaugh-map">Approach 6</a> are equivalent. Click here to conclude.</p><p><small>The equations in </small><a href="https://leetcode.com/problems/single-number-ii/editorial/?envType=study-plan-v2&envId=top-interview-150#approach-5-equation-for-bitmask">Approach 5</a><small> were</small></p><p>Approach-5</p><p></p><p><code>seen_once = (seen_once ^ num) &amp; ~seen_twice</code><code></code></p><p><code>seen_twice = (seen_twice ^ num) &amp; ~seen_once</code></p><p></p><p></p><p></p><p><small>and the equations in </small><a href="https://leetcode.com/problems/single-number-ii/editorial/?envType=study-plan-v2&envId=top-interview-150#approach-6-boolean-algebra-and-karnaugh-map">Approach 6</a><small> were</small></p><p>Approach-6</p><p></p><p><code>new_lsb = (~msb &amp; ~lsb &amp; num) | (lsb &amp; ~num)</code><code></code></p><p><code>new_msb = (lsb &amp; num) | (msb &amp; ~num)</code></p><p></p><p></p><p></p><p></p><p><h4>Modifying </h4><code><h4>new_lsb</h4></code></p><p><small>Let&#39;s focus on </small><code><small>new_lsb</small></code><small> first. Using K-Maps, we derived</small><small></small></p><p><small></small><code><small>new_lsb = (~msb &amp; ~lsb &amp; numBit) | (lsb &amp; ~numBit)</small></code></p><p><small>The RHS is</small><small></small></p><p><small></small><code><small>= (~msb &amp; ~lsb &amp; numBit) | (lsb &amp; ~numBit)</small></code></p><p><small>We can AND with 1 in the last term. This will not change the value of the term as </small><em><small>x</small></em><small>&amp;1=</small><em><small>x</small></em><small> for any </small><em><small>x</small></em><small>.</small><small></small></p><p><small>Thus, we can have</small><small></small></p><p><small></small><code><small>= (~msb &amp; ~lsb &amp; numBit) | (lsb &amp; ~numBit &amp; 1)</small></code></p><p><code><small>1</small></code><small> can be written as </small><code><small>msb | ~msb</small></code><small>. This is because </small><em><small>x</small></em><small>∣</small><em><small>x</small></em><small>ˉ</small><small>=1</small><small> for any </small><em><small>x</small></em><small>.</small><small></small></p><p><small></small><code><small>= (~msb &amp; ~lsb &amp; numBit) | (lsb &amp; ~numBit &amp; (msb | ~msb))</small></code></p><p><small>Opening Parenthesis, we get</small><small></small></p><p><small></small><code><small>= (~msb &amp; ~lsb &amp; numBit) | (lsb &amp; ~numBit &amp; msb) | (lsb &amp; ~numBit &amp; ~msb)</small></code></p><p><small>Rearranging terms inside the bracket</small><small></small></p><p><small></small><code><small>= (~msb &amp; ~lsb &amp; numBit) | (msb &amp; lsb &amp; ~numBit) | (~msb &amp; lsb &amp; ~numBit)</small></code></p><p><small>Changing the order of the term</small><small></small></p><p><small></small><code><small>= (~msb &amp; ~lsb &amp; numBit) | (~msb &amp; lsb &amp; ~numBit) | (msb &amp; lsb &amp; ~numBit)</small></code></p><p><small>Focus on the first two terms, we can take </small><code><small>~msb</small></code><small> common</small><small></small></p><p><small></small><code><small>= (~msb &amp; (~lsb &amp; numBit | lsb &amp; ~numBit)) | (msb &amp; lsb &amp; ~numBit)</small></code></p><p><small>Using property of XOR, </small><em><small>A</small></em><small>⊕</small><em><small>B</small></em><small>=</small><em><small>A</small></em><em><small>B</small></em><small>ˉ</small><small>+</small><em><small>A</small></em><small>ˉ</small><em><small>B</small></em><small></small></p><p><small></small><code><small>= (~msb &amp; (lsb ^ numBit)) | (msb &amp; lsb &amp; ~numBit)</small></code></p><p><small>Now, focus on the last term, we know that either </small><code><small>msb</small></code><small> or </small><code><small>lsb</small></code><small> will be </small><small>0</small><small>, because </small><small>11</small><small> is not a valid state. So, </small><code><small>(msb &amp; lsb)</small></code><small> will always be </small><small>0</small><small>.</small><small></small></p><p><small></small><code><small>= (~msb &amp; (lsb ^ numBit)) | (0 &amp; ~numBit)</small></code></p><p><small>which simplifies as</small><small></small></p><p><small></small><code><small>= (~msb &amp; (lsb ^ numBit)) | 0</small></code><small></small></p><p><small></small><code><small>= (~msb &amp; (lsb ^ numBit))</small></code><small></small></p><p><small></small><code><small>= (lsb ^ numBit) &amp; ~msb</small></code></p><p><small>This is for all </small><code><small>numBit</small></code><small>. Thus, for </small><code><small>num</small></code><small> (an integer) in </small><code><small>nums</small></code><small> (an array), we can write</small><small></small></p><p><small></small><code><small>new_lsb = (lsb ^ num) &amp; ~msb</small></code></p><p><small>Let&#39;s destroy the original </small><code><small>lsb</small></code><small>. So, we have</small><small></small></p><p><small></small><code><small>lsb = (lsb ^ num) &amp; ~msb</small></code></p><p><small>This is identical to</small><small></small></p><p><small></small><code><small>seen_once = (seen_once ^ num) &amp; ~seen_twice</small></code></p><p></p><p><h4>Modifying </h4><code><h4>new_msb</h4></code></p><p><small>What we are losing above is the original value of </small><code><small>lsb</small></code><small> which we will need to compute </small><code><small>new_msb</small></code><small> for this </small><code><small>num</small></code><small>. As our equation for </small><code><small>new_msb</small></code><small> is</small></p><p><code><small>new_msb = (lsb &amp; num) | (msb &amp; ~num)</small></code></p><p><small>Let&#39;s try to get the equation for this </small><code><small>new_msb</small></code><small> in terms of </small><code><small>msb</small></code><small>, </small><code><small>new_lsb</small></code><small> (which is now the same as </small><code><small>lsb</small></code><small>), and </small><code><small>num</small></code><small>.</small></p><p><small>Using boolean algebra (or K-Maps), readers are encouraged to derive the equation for </small><code><small>new_msb</small></code><small> in terms of </small><code><small>msb</small></code><small>, </small><strong><code><small>new_lsb</small></code></strong><small>, and </small><code><small>num</small></code><small>. Here is the truth table. The column </small><code><small>lsb</small></code><small> no longer matters, as </small><code><small>new_lsb</small></code><small> now represents the updated </small><code><small>lsb</small></code><small>.</small></p><p><table class="table"><tr><th>msb</th><th>lsb</th><th>num</th><th>new_msb</th><th>new_lsb</th></tr><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>❌</td><td>❌</td></tr><tr><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td><td>❌</td><td>❌</td></tr></table></p><p><small>We will use simple boolean algebra to derive the equation for </small><code><small>new_msb</small></code><small> in terms of </small><code><small>msb</small></code><small>, </small><strong><code><small>new_lsb</small></code></strong><small>, and </small><code><small>num</small></code><small>. See all rows where </small><code><small>new_msb</small></code><small> is </small><strong><small>1</small></strong><small>. Using the third row, and sixth row, we can write</small></p><p><code><small>new_msb = (msb &amp; ~num &amp; ~new_lsb) | (~msb &amp; num &amp; ~new_lsb)</small></code></p><p><small>Rearranging terms inside the bracket, we get</small><small></small></p><p><small></small><code><small>new_msb = (~new_lsb &amp; msb &amp; ~num) | (~new_lsb &amp; num &amp; ~msb)</small></code></p><p><small>Taking </small><code><small>~new_lsb</small></code><small> common, we get</small><small></small></p><p><small></small><code><small>new_msb = (~new_lsb &amp; (msb &amp; ~num | num &amp; ~msb))</small></code></p><p><small>Using property of XOR, </small><em><small>A</small></em><small>⊕</small><em><small>B</small></em><small>=</small><em><small>A</small></em><em><small>B</small></em><small>ˉ</small><small>+</small><em><small>A</small></em><small>ˉ</small><em><small>B</small></em><small>, we get</small><small></small></p><p><small></small><code><small>new_msb = (~new_lsb &amp; (msb ^ num))</small></code></p><p><small>And this </small><code><small>new_lsb</small></code><small> has been saved in </small><code><small>lsb</small></code><small> itself. So, we can write</small><small></small></p><p><small></small><code><small>new_msb = (~lsb &amp; (msb ^ num))</small></code></p><p><small>Also, we can overwrite </small><code><small>msb</small></code><small> because all two computations for the current </small><code><small>num</small></code><small> is done. So, we can write</small><small></small></p><p><small></small><code><small>msb = ~lsb &amp; (msb ^ num)</small></code></p><p><small>Rearranging terms, we get</small><small></small></p><p><small></small><code><small>msb = (msb ^ num) &amp; ~lsb</small></code></p><p><small>This is identical to</small><small></small></p><p><small></small><code><small>seen_twice = (seen_twice ^ num) &amp; ~seen_once</small></code></p><p><small>Hence, using tedious derivation, we have modified the equations for </small><a href="https://leetcode.com/problems/single-number-ii/editorial/?envType=study-plan-v2&envId=top-interview-150#approach-6-boolean-algebra-and-karnaugh-map">Approach 6</a><small>. It uses the XOR function, and smartly computes and updates </small><code><small>msb</small></code><small> and </small><code><small>lsb</small></code><small>, so that </small><code><small>new_msb</small></code><small> and </small><code><small>new_lsb</small></code><small> are not required.</small></p><p>Approach-6ㅤ(Modified)</p><p></p><p><code>lsb = (lsb ^ num) &amp; ~msb</code><code></code></p><p><code>msb = (msb ^ num) &amp; ~lsb</code></p><p></p><p></p><p></p><p><small>The </small><a href="https://leetcode.com/problems/single-number-ii/editorial/?envType=study-plan-v2&envId=top-interview-150#approach-5-equation-for-bitmask">Approach 5</a><small> derives the equation logically, while </small><a href="https://leetcode.com/problems/single-number-ii/editorial/?envType=study-plan-v2&envId=top-interview-150#approach-6-boolean-algebra-and-karnaugh-map">Approach 6</a><small> does the same using boolean algebra and K-Maps.</small></p><p></p></div>
</body>
</html>
